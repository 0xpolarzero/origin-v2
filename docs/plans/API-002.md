# API-002 Plan: Canonical Schema and Migration Hardening (TDD First)

## Overview
`001_core_schema.sql` and `002_core_constraints_indexes.sql` already create baseline tables and lifecycle checks. For API-002, focus on the remaining gaps from `docs/context/API-002.md`: relation integrity and explicit audit-driven versioning support, while preserving migration determinism.

Approach:
1. Keep historical migrations immutable; add additive migrations only.
2. Add relation integrity checks (including polymorphic relation checks) and relation-focused indexes.
3. Add explicit entity version cursor support derived from append-only audit transitions.
4. Validate with unit tests first, then integration regressions on real workflows.

## TDD Step Order (tests first, then implementation)
1. **Test:** `tests/unit/core/repositories/sqlite-migrations.test.ts` -> migration manifest includes `003_*` and `004_*` IDs after `002_*`, and IDs remain unique/sorted.
   **Implement:** create `src/core/database/migrations/003_relation_integrity.sql`, `src/core/database/migrations/004_audit_entity_versions.sql`; register both in `src/core/repositories/sqlite/migrations.ts` (`CORE_DB_MIGRATIONS`).
2. **Test:** `tests/unit/core/repositories/sqlite-migrations.test.ts` -> upgrading a DB already at `001/002` applies `003/004` once and records checksums.
   **Implement:** add concrete SQL bodies to `003_relation_integrity.sql` and `004_audit_entity_versions.sql`.
3. **Test:** `tests/unit/core/repositories/sqlite-schema.test.ts` -> relation indexes exist for high-frequency link fields (`task.project_id`, `task.source_entry_id`, `entry.accepted_task_id`, `signal.converted_entity_*`, `notification.related_entity_*`, `outbound_draft.source_signal_id`).
   **Implement:** add `CREATE INDEX IF NOT EXISTS ...` statements in `003_relation_integrity.sql`.
4. **Test:** `tests/unit/core/repositories/sqlite-schema.test.ts` -> `task.project_id` rejects non-existent project IDs on insert/update.
   **Implement:** add `task_project_id` relation validation triggers in `003_relation_integrity.sql`.
5. **Test:** `tests/unit/core/repositories/sqlite-schema.test.ts` -> `task.source_entry_id` rejects non-existent entry IDs on insert/update.
   **Implement:** add `task_source_entry_id` relation validation triggers in `003_relation_integrity.sql`.
6. **Test:** `tests/unit/core/repositories/sqlite-schema.test.ts` -> `entry.accepted_task_id` rejects non-existent task IDs on insert/update.
   **Implement:** add `entry_accepted_task_id` relation validation triggers in `003_relation_integrity.sql`.
7. **Test:** `tests/unit/core/repositories/sqlite-schema.test.ts` -> `outbound_draft.source_signal_id` rejects missing signal IDs.
   **Implement:** add `outbound_draft_source_signal_id` relation validation triggers in `003_relation_integrity.sql`.
8. **Test:** `tests/unit/core/repositories/sqlite-schema.test.ts` -> `memory_key_index.memory_id` rejects missing memory rows.
   **Implement:** add `memory_key_index_memory_id` relation validation triggers in `003_relation_integrity.sql`.
9. **Test:** `tests/unit/core/repositories/sqlite-schema.test.ts` -> `signal.converted_entity_type/id` enforces pair completeness (both null or both set) and only allows supported target types.
   **Implement:** add pair/type validation triggers for `signal` conversion fields in `003_relation_integrity.sql`.
10. **Test:** `tests/unit/core/repositories/sqlite-schema.test.ts` -> `signal.converted_entity_type/id` rejects unknown target IDs for each allowed target type.
    **Implement:** extend `signal` triggers with per-target existence checks (`task`, `event`, `note`, `project`, `outbound_draft`).
11. **Test:** `tests/unit/core/repositories/sqlite-schema.test.ts` -> `notification.related_entity_type/id` enforces pair completeness, supported entity types, and existing target rows.
    **Implement:** add relation validation triggers for `notification.related_entity_*` in `003_relation_integrity.sql`.
12. **Test:** `tests/unit/core/repositories/sqlite-schema.test.ts` -> `audit_transitions.entity_type/id` requires supported entity type and existing target entity row at write time.
    **Implement:** add audit relation validation triggers in `003_relation_integrity.sql`.
13. **Test:** `tests/unit/core/repositories/sqlite-core-repository.test.ts` -> `saveEntity` returns a deterministic `SqliteCoreRepositoryError` when relation triggers abort.
    **Implement:** normalize/keep relation-trigger abort text through existing `toRepositoryError(...)` path in `src/core/repositories/sqlite/sqlite-core-repository.ts` (only if test exposes ambiguity).
14. **Integration Test:** `tests/integration/database-core-platform.integration.test.ts` -> capture -> accept as task and signal -> convert flows persist valid cross-entity links under new relation checks.
    **Implement:** adjust workflow write ordering only if relation triggers expose ordering bugs.
15. **Test:** `tests/unit/core/repositories/sqlite-schema.test.ts` -> schema includes `entity_versions(entity_type, entity_id, latest_version, updated_at)` with PK and lookup index.
    **Implement:** create `entity_versions` table + index in `004_audit_entity_versions.sql`.
16. **Test:** `tests/unit/core/repositories/sqlite-schema.test.ts` -> migrating an existing DB backfills `entity_versions` from historical `audit_transitions` counts.
    **Implement:** add backfill SQL in `004_audit_entity_versions.sql` using grouped `audit_transitions` aggregation.
17. **Test:** `tests/unit/core/repositories/sqlite-schema.test.ts` -> inserting new audit transitions increments `entity_versions.latest_version` monotonically per entity.
    **Implement:** add `AFTER INSERT ON audit_transitions` upsert trigger in `004_audit_entity_versions.sql`.
18. **Integration Test:** `tests/integration/database-core-platform.integration.test.ts` -> checkpoint keep/recover and approval workflows keep audit trail and `entity_versions` in sync.
    **Implement:** tune migration SQL/indexes only if integration assertions fail.
19. **Test:** `tests/unit/core/repositories/sqlite-migrations.test.ts` -> rerunning full migration set with `003/004` remains idempotent and checksum-safe.
    **Implement:** finalize migration descriptors/checksums in `src/core/repositories/sqlite/migrations.ts`.

## Files to Create/Modify (with specific function signatures)

### Create
- `src/core/database/migrations/003_relation_integrity.sql`
- `src/core/database/migrations/004_audit_entity_versions.sql`

### Modify
- `src/core/repositories/sqlite/migrations.ts`
  - `export const CORE_DB_MIGRATIONS: ReadonlyArray<SqliteMigration>` (append `defineMigration(...)` entries for `003` and `004`).
- `tests/unit/core/repositories/sqlite-schema.test.ts`
  - `const applyCoreMigrations = (db: Database): Promise<void>` (helper for repetitive setup).
  - `const expectAbort = (fn: () => void, messageFragment: string): void` (assert trigger failures deterministically).
- `tests/unit/core/repositories/sqlite-migrations.test.ts`
  - `const listLedgerRows = (db: Database): Array<{ id: string; checksum: string }>` (extend assertions for new migration IDs).
- `tests/unit/core/repositories/sqlite-core-repository.test.ts`
  - existing signature under test: `saveEntity(entityType: EntityType | string, entityId: string, entity: unknown): Effect.Effect<void, SqliteCoreRepositoryError>`.
- `tests/integration/database-core-platform.integration.test.ts`
  - existing integration entrypoint under test: `buildCorePlatform(options?: BuildCorePlatformOptions): Effect.Effect<CorePlatform, Error>`.
- `src/core/repositories/sqlite/sqlite-core-repository.ts` (conditional: only if error normalization needs tightening)
  - existing helper path to adjust: `const toRepositoryError = (message: string, cause: unknown): SqliteCoreRepositoryError`.

## Tests to Write

### Unit tests
- `tests/unit/core/repositories/sqlite-migrations.test.ts`
  - manifest now includes `003`/`004` in stable order.
  - upgrade from a DB with `001/002` ledger applies only pending migrations.
  - rerun remains idempotent.
- `tests/unit/core/repositories/sqlite-schema.test.ts`
  - relation index existence assertions for all link columns.
  - trigger rejection cases for each relation field (task/project, task/entry, entry/task, outbound_draft/signal, memory_key_index/memory).
  - polymorphic relation checks for `signal` and `notification` (pair completeness, allowed type set, target existence).
  - audit transition relation checks.
  - `entity_versions` table/index exists.
  - `entity_versions` backfill from existing audit rows.
  - `entity_versions` auto-increment on new audit transitions.
- `tests/unit/core/repositories/sqlite-core-repository.test.ts`
  - relation constraint failures surfaced as deterministic repository errors (message includes trigger reason).

### Integration tests
- `tests/integration/database-core-platform.integration.test.ts`
  - existing capture/signal/approval/checkpoint workflows still pass with strict relation checks enabled.
  - persisted audit transitions and `entity_versions` remain synchronized for entities touched by workflows.

## Risks and Mitigations
1. **Risk:** editing old migrations breaks checksum history for existing DBs.
   **Mitigation:** never modify `001/002`; add only `003/004`.
2. **Risk:** new relation checks reject legacy rows during migration/backfill.
   **Mitigation:** run precondition queries in migration tests and handle legacy-invalid rows explicitly (fail fast with clear trigger messages or controlled cleanup strategy).
3. **Risk:** polymorphic validation triggers become brittle when new entity types are added later.
   **Mitigation:** keep allowed-type list centralized in migration SQL comments + add regression test that fails when entity type set drifts.
4. **Risk:** write throughput regression from extra relation/versioning triggers.
   **Mitigation:** add supporting indexes in same migration and keep trigger logic simple/predicate-based.
5. **Risk:** service-level write ordering might violate stricter constraints.
   **Mitigation:** integration tests around conversion/approval/checkpoint flows before implementation changes.

## How to Verify Against Acceptance Criteria
1. **Canonical schema covers required objects**
   - `sqlite_master` assertions pass for all required tables (`entry`, `task`, `event`, `project`, `note`, `signal`, `job`, `notification`, `view`, `memory`, `checkpoint`) plus audit/versioning support tables.
2. **Relations are implemented and enforced**
   - trigger tests fail on invalid references and pass for valid workflow writes.
3. **Audit/versioning support is concrete**
   - `audit_transitions` remains append-only and `entity_versions` is backfilled + incremented from audit writes.
4. **Migrations are deterministic and safe**
   - migration ordering, checksum, upgrade-from-previous, and idempotency tests all pass.
5. **Quality gates for this slice**
   - `bun test tests/unit/core/repositories/sqlite-migrations.test.ts`
   - `bun test tests/unit/core/repositories/sqlite-schema.test.ts`
   - `bun test tests/unit/core/repositories/sqlite-core-repository.test.ts`
   - `bun test tests/integration/database-core-platform.integration.test.ts`
   - `bun run typecheck`
