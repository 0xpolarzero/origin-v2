# API-006 Plan: Define explicit API and schema contracts for auditability (TDD First)

## Overview of the approach
This ticket closes the documentation gap identified in `docs/context/API-006.md`: route and persisted-schema contracts already exist in code/tests, but there are no dedicated contract docs for exact reviewer matching.

Implementation approach:
1. Add machine-checkable contract docs under `docs/contracts/` for workflow API routes and persisted schema.
2. Add contract-doc policy tooling that parses those docs and reports drift.
3. Add tests that fail whenever docs and source-of-truth code/schema diverge.

This keeps docs reviewer-friendly while still enforcing exactness through tests.

## TDD step order (tests before implementation)
1. **Test:** `tests/unit/tooling/contract-doc-policy.test.ts` -> add RED case for Markdown table extraction by heading (`Route Key`, `Method`, `Path`).
   **Implement:** `src/core/tooling/contract-doc-policy.ts` -> `parseMarkdownTableRows(markdown: string, heading: string): ReadonlyArray<Record<string, string>>`.

2. **Test:** `tests/unit/tooling/contract-doc-policy.test.ts` -> add RED case for route-contract parsing, normalized output, and duplicate-key detection.
   **Implement:** `src/core/tooling/contract-doc-policy.ts` ->
   - `parseWorkflowRouteContractRows(markdown: string): ReadonlyArray<WorkflowRouteContractRow>`
   - `findWorkflowRouteContractViolations(params: { documented: ReadonlyArray<WorkflowRouteContractRow>; expectedPaths: Record<WorkflowRouteKey, string>; expectedMethodByKey?: Record<WorkflowRouteKey, "POST">; }): ReadonlyArray<WorkflowRouteContractViolation>`

3. **Integration Test:** `tests/integration/api-contract-docs.integration.test.ts` -> add RED case requiring `docs/contracts/workflow-api-routes.md` to exist and match `WORKFLOW_ROUTE_PATHS` + `makeWorkflowRoutes(...)` (`POST` + exact path per key).
   **Implement:** create `docs/contracts/workflow-api-routes.md` with canonical route matrix (`Route Key | Method | Path`).

4. **Integration Test:** `tests/integration/api-contract-docs.integration.test.ts` -> add RED case requiring explicit validator/error/transport sections in route doc (date coercion rule, non-empty string rule, status mapping and sanitized body shape).
   **Implement:** extend `docs/contracts/workflow-api-routes.md` with:
   - shared validation rules section
   - service-error to API status mapping section
   - HTTP dispatcher behavior section
   - source-of-truth pointers (`contracts.ts`, `routes.ts`, `errors.ts`, `http-dispatch.ts`).

5. **Test:** `tests/unit/tooling/contract-doc-policy.test.ts` -> add RED case for persisted-schema doc parsing (migration IDs, table rows, trigger names, index names).
   **Implement:** `src/core/tooling/contract-doc-policy.ts` ->
   - `parsePersistedSchemaContract(markdown: string): PersistedSchemaContract`
   - `findPersistedSchemaContractViolations(params: { documented: PersistedSchemaContract; expected: PersistedSchemaContractExpected; }): ReadonlyArray<PersistedSchemaContractViolation>`.

6. **Integration Test:** `tests/integration/api-contract-docs.integration.test.ts` -> add RED case requiring `docs/contracts/persisted-schema.md` migration ledger to exactly match `CORE_DB_MIGRATIONS` order.
   **Implement:** create `docs/contracts/persisted-schema.md` with migration-contract section and ordered manifest table.

7. **Integration Test:** `tests/integration/api-contract-docs.integration.test.ts` -> add RED case requiring documented table names/columns to match migrated in-memory sqlite schema (`PRAGMA table_info`).
   **Implement:** extend `docs/contracts/persisted-schema.md` with canonical persisted table/column matrix for all application tables and support tables.

8. **Integration Test:** `tests/integration/api-contract-docs.integration.test.ts` -> add RED case requiring documented trigger names and index names to match migrated sqlite schema (`sqlite_master`, filtered for user-defined objects).
   **Implement:** extend `docs/contracts/persisted-schema.md` with complete trigger and index contract sections (including `entity_versions` and `job_run_history` contract artifacts).

9. **Integration Test:** `tests/integration/api-contract-docs.integration.test.ts` -> add RED case requiring root docs index to expose both new contract docs.
   **Implement:** update `README.md` to link:
   - `docs/contracts/workflow-api-routes.md`
   - `docs/contracts/persisted-schema.md`.

10. **Verification step (GREEN):** run targeted and slice-level checks.
    **Implement:** no code changes; stabilize formatting/content until all checks pass.

## Files to create/modify (with specific function signatures)

### Create
- `src/core/tooling/contract-doc-policy.ts`
  - `export interface WorkflowRouteContractRow { key: WorkflowRouteKey; method: "POST"; path: string; }`
  - `export interface WorkflowRouteContractViolation { key: string; issue: "missing" | "extra" | "method-mismatch" | "path-mismatch"; expectedMethod?: string; expectedPath?: string; documentedMethod?: string; documentedPath?: string; }`
  - `export interface PersistedSchemaContract { migrationIds: ReadonlyArray<string>; tables: ReadonlyArray<{ table: string; columns: ReadonlyArray<string> }>; triggerNames: ReadonlyArray<string>; indexNames: ReadonlyArray<string>; }`
  - `export interface PersistedSchemaContractExpected { migrationIds: ReadonlyArray<string>; tables: ReadonlyArray<{ table: string; columns: ReadonlyArray<string> }>; triggerNames: ReadonlyArray<string>; indexNames: ReadonlyArray<string>; }`
  - `export const parseMarkdownTableRows: (markdown: string, heading: string) => ReadonlyArray<Record<string, string>>`
  - `export const parseWorkflowRouteContractRows: (markdown: string) => ReadonlyArray<WorkflowRouteContractRow>`
  - `export const findWorkflowRouteContractViolations: (params: { documented: ReadonlyArray<WorkflowRouteContractRow>; expectedPaths: Record<WorkflowRouteKey, string>; expectedMethodByKey?: Record<WorkflowRouteKey, "POST">; }) => ReadonlyArray<WorkflowRouteContractViolation>`
  - `export const parsePersistedSchemaContract: (markdown: string) => PersistedSchemaContract`
  - `export const findPersistedSchemaContractViolations: (params: { documented: PersistedSchemaContract; expected: PersistedSchemaContractExpected; }) => ReadonlyArray<{ subject: string; issue: "missing" | "extra" | "mismatch"; expected?: string; documented?: string; }>`

- `tests/unit/tooling/contract-doc-policy.test.ts`
- `tests/integration/api-contract-docs.integration.test.ts`
- `docs/contracts/workflow-api-routes.md`
- `docs/contracts/persisted-schema.md`

### Modify
- `README.md`

## Tests to write (unit + integration)

### Unit tests
- `tests/unit/tooling/contract-doc-policy.test.ts`
  - parses heading-scoped Markdown pipe tables deterministically.
  - parses workflow route rows (`key/method/path`) and rejects duplicate keys.
  - detects route contract violations (missing/extra/path mismatch/method mismatch).
  - parses persisted-schema sections (migration IDs, tables+columns, triggers, indexes).
  - detects persisted-schema violations (missing/extra/mismatch).

### Integration tests
- `tests/integration/api-contract-docs.integration.test.ts`
  - `workflow-api-routes.md` exists and exactly matches route keys and paths from `WORKFLOW_ROUTE_PATHS`; method is `POST` for every documented route.
  - route contract doc includes required validation/error/transport contract sections.
  - `persisted-schema.md` migration IDs exactly match `CORE_DB_MIGRATIONS` order.
  - documented tables/columns exactly match migrated sqlite schema introspection.
  - documented trigger names exactly match user-defined trigger names in migrated sqlite schema.
  - documented index names exactly match user-defined index names in migrated sqlite schema.
  - `README.md` links both contract docs.

## Risks and mitigations
1. **Risk:** Contract docs drift from code after future route/schema changes.
   **Mitigation:** Keep parity integration tests as required gate checks for this contract surface.

2. **Risk:** Markdown parser is brittle to formatting-only edits.
   **Mitigation:** Constrain doc format with fixed headings/tables and cover parser behavior in dedicated unit tests.

3. **Risk:** SQLite introspection can include internal autoindexes that should not be documented.
   **Mitigation:** Filter `sqlite_autoindex_*` and compare only user-defined indexes/triggers.

4. **Risk:** Large trigger/index inventories are error-prone to maintain manually.
   **Mitigation:** Keep sorted canonical lists in docs and enforce exact set equality via tests.

5. **Risk:** Ambiguous field naming between API camelCase and SQL snake_case can confuse reviewers.
   **Mitigation:** Preserve exact source naming in each contract doc and add a short naming-policy note.

## How to verify against acceptance criteria
Acceptance criteria mapping:
- **Dedicated route contract doc exists for exact matching:**
  - `docs/contracts/workflow-api-routes.md`
  - parity integration assertions vs `WORKFLOW_ROUTE_PATHS` and `makeWorkflowRoutes(...)`.

- **Dedicated persisted schema contract doc exists for exact matching:**
  - `docs/contracts/persisted-schema.md`
  - parity integration assertions vs `CORE_DB_MIGRATIONS` + migrated sqlite introspection.

- **No ambiguity for future route/schema reviews:**
  - parser + violation tests ensure structured contract format.
  - integration tests fail on any route/schema/doc drift.

Verification commands:
- `bun test tests/unit/tooling/contract-doc-policy.test.ts`
- `bun test tests/integration/api-contract-docs.integration.test.ts`
- `bun test tests/unit/api/workflows/routes.test.ts`
- `bun test tests/unit/core/repositories/sqlite-migrations.test.ts`
- `bun test tests/unit/core/repositories/sqlite-schema.test.ts`
- `bun run test:integration:api`
- `bun run test:integration:db`
- `bun run typecheck`
