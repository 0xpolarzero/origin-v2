diff --git a/.bun-tag b/.bun-tag
new file mode 100644
index 0000000..1bf12e5
--- /dev/null
+++ b/.bun-tag
@@ -0,0 +1 @@
+evmts-super-ralph-ef8726d
\ No newline at end of file
diff --git a/.bun-tag-b4b20dce721c4dc0 b/.bun-tag-b4b20dce721c4dc0
new file mode 100644
index 0000000..e69de29
diff --git a/package.json b/package.json
index 2368a78..093cbea 100644
--- a/package.json
+++ b/package.json
@@ -13,7 +13,11 @@
     ".": "./src/index.ts",
     "./selectors": "./src/selectors.ts",
     "./components": "./src/components/index.ts",
-    "./cli/clarifications": "./src/cli/clarifications.ts"
+    "./schemas": "./src/schemas.ts",
+    "./gate-config": "./src/cli/gate-config.ts",
+    "./ticket-gates": "./src/components/ticket-gates.ts",
+    "./cli/clarifications": "./src/cli/clarifications.ts",
+    "./cli/fallback-config": "./src/cli/fallback-config.ts"
   },
   "files": [
     "src/",
diff --git a/src/cli/fallback-config.ts b/src/cli/fallback-config.ts
new file mode 100644
index 0000000..ca07a3b
--- /dev/null
+++ b/src/cli/fallback-config.ts
@@ -0,0 +1,133 @@
+import { existsSync } from "node:fs";
+import { basename, isAbsolute, join, relative } from "node:path";
+
+import {
+  buildGateCommandConfig,
+  type ScriptRunner,
+} from "./gate-config";
+import { DEFAULT_ALLOWED_COMMIT_TYPES } from "../components/commit-policy";
+
+function hasScript(packageScripts: Record<string, string>, scriptName: string): boolean {
+  const command = packageScripts[scriptName];
+  return typeof command === "string" && command.trim().length > 0;
+}
+
+export function detectScriptRunner(repoRoot: string): ScriptRunner {
+  if (existsSync(join(repoRoot, "bun.lock")) || existsSync(join(repoRoot, "bun.lockb"))) return "bun";
+  if (existsSync(join(repoRoot, "pnpm-lock.yaml"))) return "pnpm";
+  if (existsSync(join(repoRoot, "yarn.lock"))) return "yarn";
+  return "npm";
+}
+
+function slugify(value: string): string {
+  return value
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, "-")
+    .replace(/^-+|-+$/g, "") || "project";
+}
+
+export function toRepoRelativePath(repoRoot: string, pathValue: string): string {
+  const normalizedInput = pathValue.trim().replaceAll("\\", "/");
+  if (normalizedInput.length === 0) return ".";
+
+  if (!isAbsolute(pathValue)) {
+    return normalizedInput
+      .replace(/^\.\/+/, "")
+      .replace(/^\/+/, "");
+  }
+
+  const relativeCandidate = relative(repoRoot, pathValue).replaceAll("\\", "/");
+  if (relativeCandidate.length === 0) return ".";
+  if (relativeCandidate.startsWith("..")) {
+    return basename(pathValue);
+  }
+
+  return relativeCandidate;
+}
+
+export function buildFallbackConfig(
+  repoRoot: string,
+  promptSpecPath: string,
+  packageScripts: Record<string, string>,
+) {
+  const normalizedPromptSpecPath = toRepoRelativePath(repoRoot, promptSpecPath);
+  const runner = detectScriptRunner(repoRoot);
+  const hasNodeGateScripts = hasScript(packageScripts, "test") && hasScript(packageScripts, "typecheck");
+  const buildCmds: Record<string, string> = {};
+  const testCmds: Record<string, string> = {};
+
+  if (hasNodeGateScripts) {
+    const gateConfig = buildGateCommandConfig(runner, packageScripts);
+    Object.assign(buildCmds, gateConfig.buildCmds);
+    Object.assign(testCmds, gateConfig.testCmds);
+  }
+
+  if (existsSync(join(repoRoot, "go.mod"))) {
+    buildCmds.go = buildCmds.go ?? "go build ./...";
+    testCmds.go = testCmds.go ?? "go test ./...";
+  }
+
+  if (existsSync(join(repoRoot, "Cargo.toml"))) {
+    buildCmds.rust = buildCmds.rust ?? "cargo build";
+    testCmds.rust = testCmds.rust ?? "cargo test";
+  }
+
+  if (Object.keys(buildCmds).length === 0 || Object.keys(testCmds).length === 0) {
+    throw new Error(
+      "Unable to derive runnable gate commands. Configure package.json test/typecheck scripts or provide Go/Rust project files.",
+    );
+  }
+
+  const specsPathCandidates = [
+    "docs/specs/engineering.md",
+    "docs/specs",
+    "specs",
+    normalizedPromptSpecPath,
+  ];
+
+  const chosenSpecs =
+    specsPathCandidates.find((candidate) => existsSync(join(repoRoot, candidate))) ??
+    normalizedPromptSpecPath;
+
+  const projectName = basename(repoRoot);
+  const maxConcurrency = Math.min(
+    Math.max(Number(process.env.WORKFLOW_MAX_CONCURRENCY ?? "6") || 6, 1),
+    32,
+  );
+
+  return {
+    projectName,
+    projectId: slugify(projectName),
+    focuses: [
+      { id: "core", name: "Core Platform" },
+      { id: "api", name: "API and Data" },
+      { id: "workflow", name: "Workflow and Automation" },
+    ],
+    specsPath: chosenSpecs,
+    referenceFiles: [
+      normalizedPromptSpecPath,
+      existsSync(join(repoRoot, "README.md")) ? "README.md" : "",
+      existsSync(join(repoRoot, "docs")) ? "docs" : "",
+    ].filter(Boolean),
+    buildCmds,
+    testCmds,
+    commitPolicy: {
+      allowedTypes: [...DEFAULT_ALLOWED_COMMIT_TYPES],
+      requireAtomicChecks: true,
+    },
+    agentSafetyPolicy: {
+      riskyModeEnabled: false,
+      approvalRequiredPhases: [],
+    },
+    preLandChecks: Object.values(buildCmds),
+    postLandChecks: Object.values(testCmds),
+    codeStyle: "Follow existing project conventions and keep changes minimal and test-driven.",
+    reviewChecklist: [
+      "Spec compliance",
+      "Tests cover behavior changes",
+      "No regression risk in existing flows",
+      "Error handling and observability",
+    ],
+    maxConcurrency,
+  };
+}
diff --git a/src/cli/gate-config.ts b/src/cli/gate-config.ts
new file mode 100644
index 0000000..23febe5
--- /dev/null
+++ b/src/cli/gate-config.ts
@@ -0,0 +1,92 @@
+export type ScriptRunner = "bun" | "pnpm" | "yarn" | "npm";
+
+export type GateCommandConfig = {
+  buildCmds: Record<string, string>;
+  testCmds: Record<string, string>;
+  preLandChecks: string[];
+  postLandChecks: string[];
+};
+
+const REQUIRED_GATE_SCRIPTS = ["test", "typecheck"] as const;
+
+function hasScript(packageScripts: Record<string, string>, scriptName: string): boolean {
+  const command = packageScripts[scriptName];
+  return typeof command === "string" && command.trim().length > 0;
+}
+
+function scriptCommand(runner: ScriptRunner, scriptName: string): string {
+  if (runner === "bun") return `bun run ${scriptName}`;
+  if (runner === "pnpm") return `pnpm run ${scriptName}`;
+  if (runner === "yarn") return `yarn ${scriptName}`;
+  return `npm run ${scriptName}`;
+}
+
+function firstExistingScript(packageScripts: Record<string, string>, candidates: string[]): string | null {
+  for (const scriptName of candidates) {
+    if (hasScript(packageScripts, scriptName)) {
+      return scriptName;
+    }
+  }
+
+  return null;
+}
+
+export const assertRequiredGateScripts = (packageScripts: Record<string, string>): void => {
+  const missingScripts = REQUIRED_GATE_SCRIPTS.filter((scriptName) => !hasScript(packageScripts, scriptName));
+
+  if (missingScripts.length > 0) {
+    throw new Error(`Missing required package scripts: ${missingScripts.join(", ")}`);
+  }
+};
+
+export const resolveFocusTestCommands = (
+  runner: ScriptRunner,
+  packageScripts: Record<string, string>,
+): Record<string, string> => {
+  const testCmds: Record<string, string> = {
+    test: scriptCommand(runner, "test"),
+  };
+
+  const focusScriptCandidates: Record<string, string[]> = {
+    core: ["test:core", "test:unit:core", "test:integration:core"],
+    api: ["test:integration:api", "test:api"],
+    workflow: ["test:integration:workflow", "test:workflow"],
+    db: ["test:integration:db", "test:db"],
+  };
+
+  for (const [focus, candidates] of Object.entries(focusScriptCandidates)) {
+    const selectedScript = firstExistingScript(packageScripts, candidates);
+    if (selectedScript) {
+      testCmds[focus] = scriptCommand(runner, selectedScript);
+    }
+  }
+
+  return testCmds;
+};
+
+export const buildGateCommandConfig = (
+  runner: ScriptRunner,
+  packageScripts: Record<string, string>,
+): GateCommandConfig => {
+  assertRequiredGateScripts(packageScripts);
+
+  const buildCmds: Record<string, string> = {
+    typecheck: scriptCommand(runner, "typecheck"),
+  };
+
+  if (hasScript(packageScripts, "build")) {
+    buildCmds.build = scriptCommand(runner, "build");
+  }
+  if (hasScript(packageScripts, "lint")) {
+    buildCmds.lint = scriptCommand(runner, "lint");
+  }
+
+  const testCmds = resolveFocusTestCommands(runner, packageScripts);
+
+  return {
+    buildCmds,
+    testCmds,
+    preLandChecks: Object.values(buildCmds),
+    postLandChecks: Object.values(testCmds),
+  };
+};
diff --git a/src/cli/index.ts b/src/cli/index.ts
index 633e857..b05bc06 100644
--- a/src/cli/index.ts
+++ b/src/cli/index.ts
@@ -18,9 +18,10 @@
 
 import { existsSync } from "node:fs";
 import { mkdir, readFile, writeFile } from "node:fs/promises";
-import { basename, dirname, join, resolve } from "node:path";
+import { dirname, join, resolve } from "node:path";
 import { fileURLToPath } from "node:url";
 import { randomUUID } from "node:crypto";
+import { buildFallbackConfig } from "./fallback-config";
 
 type ParsedArgs = {
   positional: string[];
@@ -113,27 +114,6 @@ async function loadPackageScripts(repoRoot: string): Promise<Record<string, stri
   }
 }
 
-function detectScriptRunner(repoRoot: string): "bun" | "pnpm" | "yarn" | "npm" {
-  if (existsSync(join(repoRoot, "bun.lock")) || existsSync(join(repoRoot, "bun.lockb"))) return "bun";
-  if (existsSync(join(repoRoot, "pnpm-lock.yaml"))) return "pnpm";
-  if (existsSync(join(repoRoot, "yarn.lock"))) return "yarn";
-  return "npm";
-}
-
-function scriptCommand(runner: "bun" | "pnpm" | "yarn" | "npm", scriptName: string): string {
-  if (runner === "bun") return `bun run ${scriptName}`;
-  if (runner === "pnpm") return `pnpm run ${scriptName}`;
-  if (runner === "yarn") return `yarn ${scriptName}`;
-  return `npm run ${scriptName}`;
-}
-
-function slugify(value: string): string {
-  return value
-    .toLowerCase()
-    .replace(/[^a-z0-9]+/g, "-")
-    .replace(/^-+|-+$/g, "") || "project";
-}
-
 async function commandExists(command: string, cwd: string): Promise<boolean> {
   try {
     const proc = Bun.spawn(["which", command], { cwd, stdout: "pipe", stderr: "pipe" });
@@ -154,85 +134,6 @@ async function detectAgents(repoRoot: string): Promise<{ claude: boolean; codex:
   return { claude, codex, gh };
 }
 
-function buildFallbackConfig(repoRoot: string, promptSpecPath: string, packageScripts: Record<string, string>) {
-  const runner = detectScriptRunner(repoRoot);
-
-  const buildCmds: Record<string, string> = {};
-  const testCmds: Record<string, string> = {};
-
-  if (packageScripts.typecheck) {
-    buildCmds.typecheck = scriptCommand(runner, "typecheck");
-  }
-  if (packageScripts.build) {
-    buildCmds.build = scriptCommand(runner, "build");
-  }
-  if (packageScripts.lint) {
-    buildCmds.lint = scriptCommand(runner, "lint");
-  }
-
-  if (packageScripts.test) {
-    testCmds.test = scriptCommand(runner, "test");
-  }
-
-  if (existsSync(join(repoRoot, "go.mod"))) {
-    buildCmds.go = buildCmds.go ?? "go build ./...";
-    testCmds.go = testCmds.go ?? "go test ./...";
-  }
-
-  if (existsSync(join(repoRoot, "Cargo.toml"))) {
-    buildCmds.rust = buildCmds.rust ?? "cargo build";
-    testCmds.rust = testCmds.rust ?? "cargo test";
-  }
-
-  if (Object.keys(buildCmds).length === 0) {
-    buildCmds.verify = runner === "bun" ? "bun run typecheck" : "echo \"Add build/typecheck command\"";
-  }
-
-  if (Object.keys(testCmds).length === 0) {
-    testCmds.tests = runner === "bun" ? "bun test" : "echo \"Add test command\"";
-  }
-
-  const specsPathCandidates = [
-    join(repoRoot, "docs/specs/engineering.md"),
-    join(repoRoot, "docs/specs"),
-    join(repoRoot, "specs"),
-    promptSpecPath,
-  ];
-
-  const chosenSpecs = specsPathCandidates.find((candidate) => existsSync(candidate)) ?? promptSpecPath;
-
-  const projectName = basename(repoRoot);
-  const maxConcurrency = Math.min(Math.max(Number(process.env.WORKFLOW_MAX_CONCURRENCY ?? "6") || 6, 1), 32);
-
-  return {
-    projectName,
-    projectId: slugify(projectName),
-    focuses: [
-      { id: "core", name: "Core Platform" },
-      { id: "api", name: "API and Data" },
-      { id: "workflow", name: "Workflow and Automation" },
-    ],
-    specsPath: chosenSpecs,
-    referenceFiles: [
-      promptSpecPath,
-      existsSync(join(repoRoot, "README.md")) ? "README.md" : "",
-      existsSync(join(repoRoot, "docs")) ? "docs" : "",
-    ].filter(Boolean),
-    buildCmds,
-    testCmds,
-    preLandChecks: Object.values(buildCmds),
-    postLandChecks: Object.values(testCmds),
-    codeStyle: "Follow existing project conventions and keep changes minimal and test-driven.",
-    reviewChecklist: [
-      "Spec compliance",
-      "Tests cover behavior changes",
-      "No regression risk in existing flows",
-      "Error handling and observability",
-    ],
-    maxConcurrency,
-  };
-}
-
 function findSmithersCliPath(repoRoot: string): string | null {
   const candidates = [
     join(repoRoot, "node_modules/smithers-orchestrator/src/cli/index.ts"),
@@ -275,6 +176,23 @@ const cliDir = import.meta.dir || dirname(fileURLToPath(import.meta.url));
 const superRalphSourceRoot = dirname(dirname(cliDir));
 const runningFromSource = existsSync(join(superRalphSourceRoot, 'src/components/SuperRalph.tsx'));
 
+function resolveWorkflowImportPrefix(params: {
+  isSuperRalphRepo: boolean;
+  runningFromSource: boolean;
+}): string {
+  const { isSuperRalphRepo, runningFromSource } = params;
+
+  if (isSuperRalphRepo) {
+    return "../../src";
+  }
+
+  if (runningFromSource) {
+    return "super-ralph";
+  }
+
+  return "super-ralph";
+}
+
 function renderWorkflowFile(params: {
   promptText: string;
   promptSpecPath: string;
@@ -294,30 +212,45 @@ function renderWorkflowFile(params: {
   const isSuperRalphRepo = existsSync(join(repoRoot, 'src/components/SuperRalph.tsx')) &&
                            existsSync(join(repoRoot, 'src/components/ClarifyingQuestions.tsx'));
 
-  let importPrefix: string;
-  if (isSuperRalphRepo) {
-    // Generating workflow IN super-ralph repo - use relative imports
-    importPrefix = '../../src';
-  } else if (runningFromSource) {
-    // Running from super-ralph source for another repo - use absolute imports to source
-    importPrefix = superRalphSourceRoot + '/src';
-  } else {
-    // Running from installed package
-    importPrefix = 'super-ralph';
-  }
+  const importPrefix = resolveWorkflowImportPrefix({
+    isSuperRalphRepo,
+    runningFromSource,
+  });
+  const promptSpecPathFromConfig =
+    typeof fallbackConfig?.referenceFiles?.[0] === "string" &&
+    fallbackConfig.referenceFiles[0].trim().length > 0
+      ? fallbackConfig.referenceFiles[0]
+      : promptSpecPath;
 
   return `import React from "react";
 import { createSmithers, ClaudeCodeAgent, CodexAgent, Sequence, Parallel } from "smithers-orchestrator";
+import { dirname, resolve } from "node:path";
+import { fileURLToPath } from "node:url";
 import { SuperRalph } from "${importPrefix}";
-import { InterpretConfig, Monitor } from "${importPrefix}/components";
+import {
+  InterpretConfig,
+  Monitor,
+  normalizeAgentSafetyPolicy,
+  normalizeCommitPolicy,
+  type AgentSafetyPolicy,
+} from "${importPrefix}/components";
 import { ralphOutputSchemas } from "${importPrefix}";
 
-const REPO_ROOT = ${JSON.stringify(repoRoot)};
-const DB_PATH = ${JSON.stringify(dbPath)};
+function resolveRepoRootFromWorkflowFile(): string {
+  return resolve(dirname(fileURLToPath(import.meta.url)), "..", "..");
+}
+
+const REPO_ROOT = resolveRepoRootFromWorkflowFile();
+
+function resolveRepoPath(pathFromRepoRoot: string): string {
+  return resolve(REPO_ROOT, pathFromRepoRoot);
+}
+
+const DB_PATH = resolveRepoPath(".super-ralph/workflow.db");
 const HAS_CLAUDE = ${detectedAgents.claude};
 const HAS_CODEX = ${detectedAgents.codex};
 const PROMPT_TEXT = ${JSON.stringify(promptText)};
-const PROMPT_SPEC_PATH = ${JSON.stringify(promptSpecPath)};
+const PROMPT_SPEC_PATH = resolveRepoPath(${JSON.stringify(promptSpecPathFromConfig)});
 const PACKAGE_SCRIPTS = ${JSON.stringify(packageScripts, null, 2)};
 const FALLBACK_CONFIG = ${JSON.stringify(fallbackConfig, null, 2)};
 const CLARIFICATION_SESSION = ${JSON.stringify(clarificationSession)};
@@ -327,84 +260,199 @@ const { smithers, outputs, Workflow } = createSmithers(
   { dbPath: DB_PATH }
 );
 
-function createClaude(systemPrompt: string) {
+function resolveAgentSafetyPolicy(input: unknown): AgentSafetyPolicy {
+  const envRiskyModeEnabled = process.env.SUPER_RALPH_RISKY_MODE === "1";
+  const envApprovalRequiredPhases = (process.env.SUPER_RALPH_APPROVAL_REQUIRED_PHASES ?? "")
+    .split(",")
+    .map((phase) => phase.trim())
+    .filter((phase) => phase.length > 0);
+
+  if (!envRiskyModeEnabled) {
+    return normalizeAgentSafetyPolicy(input);
+  }
+
+  const normalizedInput = normalizeAgentSafetyPolicy(input);
+  return normalizeAgentSafetyPolicy({
+    riskyModeEnabled: true,
+    approvalRequiredPhases:
+      envApprovalRequiredPhases.length > 0
+        ? envApprovalRequiredPhases
+        : normalizedInput.approvalRequiredPhases,
+  });
+}
+
+function resolveCommitPolicy(fallback: unknown, candidate: unknown) {
+  const normalizedFallback = normalizeCommitPolicy(fallback);
+  if (!candidate || typeof candidate !== "object") {
+    return normalizedFallback;
+  }
+
+  const candidateRecord = candidate as {
+    allowedTypes?: unknown;
+    requireAtomicChecks?: unknown;
+  };
+
+  return normalizeCommitPolicy({
+    allowedTypes: candidateRecord.allowedTypes ?? normalizedFallback.allowedTypes,
+    requireAtomicChecks:
+      typeof candidateRecord.requireAtomicChecks === "boolean"
+        ? candidateRecord.requireAtomicChecks
+        : normalizedFallback.requireAtomicChecks,
+  });
+}
+
+function createClaude(systemPrompt: string, policy: AgentSafetyPolicy) {
+  const safeDefaults = {
+    yolo: false,
+    dangerouslySkipPermissions: false,
+  };
+
   return new ClaudeCodeAgent({
+    ...safeDefaults,
     model: "claude-sonnet-4-6",
     systemPrompt,
     cwd: REPO_ROOT,
-    dangerouslySkipPermissions: true,
+    yolo: policy.riskyModeEnabled,
+    dangerouslySkipPermissions: policy.riskyModeEnabled,
     timeoutMs: 60 * 60 * 1000,
   });
 }
 
-function createCodex(systemPrompt: string) {
+function createCodex(systemPrompt: string, policy: AgentSafetyPolicy) {
+  const safeDefaults = {
+    yolo: false,
+  };
+
   return new CodexAgent({
+    ...safeDefaults,
     model: "gpt-5.3-codex",
     systemPrompt,
     cwd: REPO_ROOT,
-    yolo: true,
+    yolo: policy.riskyModeEnabled,
     timeoutMs: 60 * 60 * 1000,
   });
 }
 
-function choose(primary: "claude" | "codex", systemPrompt: string) {
-  if (primary === "claude" && HAS_CLAUDE) return createClaude(systemPrompt);
-  if (primary === "codex" && HAS_CODEX) return createCodex(systemPrompt);
-  if (HAS_CLAUDE) return createClaude(systemPrompt);
-  return createCodex(systemPrompt);
+function choose(primary: "claude" | "codex", systemPrompt: string, policy: AgentSafetyPolicy) {
+  if (primary === "claude" && HAS_CLAUDE) return createClaude(systemPrompt, policy);
+  if (primary === "codex" && HAS_CODEX) return createCodex(systemPrompt, policy);
+  if (HAS_CLAUDE) return createClaude(systemPrompt, policy);
+  return createCodex(systemPrompt, policy);
 }
 
-const planningAgent = choose("claude", "Plan and research next tickets.");
-const implementationAgent = choose("claude", "Implement with test-driven development and jj workflows.");
-const testingAgent = choose("claude", "Run tests and validate behavior changes.");
-const reviewingAgent = choose("codex", "Review for regressions, spec drift, and correctness.");
-const reportingAgent = choose("claude", "Write concise, accurate ticket status reports.");
-
-export default smithers((ctx) => (
-  <Workflow name="super-ralph-full">
-    <Sequence>
-      {/* Step 1: Interpret Config (clarification session already collected by CLI) */}
-      <InterpretConfig
-        prompt={PROMPT_TEXT}
-        clarificationSession={CLARIFICATION_SESSION}
-        repoRoot={REPO_ROOT}
-        fallbackConfig={FALLBACK_CONFIG}
-        packageScripts={PACKAGE_SCRIPTS}
-        detectedAgents={{
-          claude: HAS_CLAUDE,
-          codex: HAS_CODEX,
-          gh: false,
-        }}
-        agent={planningAgent}
-      />
-
-      {/* Step 2: Run SuperRalph + Monitor in Parallel */}
-      <Parallel>
-        <SuperRalph
-          ctx={ctx}
-          outputs={outputs}
-          {...((ctx.outputMaybe("interpret-config", outputs.interpret_config) as any) || FALLBACK_CONFIG)}
-          agents={{
-            planning: planningAgent,
-            implementation: implementationAgent,
-            testing: testingAgent,
-            reviewing: reviewingAgent,
-            reporting: reportingAgent,
-          }}
-        />
+function mergeCommandMap(
+  fallback: Record<string, string>,
+  candidate: unknown,
+): Record<string, string> {
+  const merged = { ...fallback };
+  if (!candidate || typeof candidate !== "object") return merged;
 
-        <Monitor
-          dbPath={DB_PATH}
-          runId={ctx.runId}
-          config={(ctx.outputMaybe("interpret-config", outputs.interpret_config) as any) || FALLBACK_CONFIG}
-          clarificationSession={CLARIFICATION_SESSION}
+  for (const [key, value] of Object.entries(candidate as Record<string, unknown>)) {
+    if (typeof value === "string" && value.trim().length > 0) {
+      merged[key] = value;
+    }
+  }
+
+  return merged;
+}
+
+function resolveRuntimeConfig(ctx: any) {
+  const interpreted = (ctx.outputMaybe("interpret-config", outputs.interpret_config) as any) ?? {};
+  const buildCmds = mergeCommandMap(FALLBACK_CONFIG.buildCmds, interpreted.buildCmds);
+  const testCmds = mergeCommandMap(FALLBACK_CONFIG.testCmds, interpreted.testCmds);
+  const commitPolicy = resolveCommitPolicy(FALLBACK_CONFIG.commitPolicy, interpreted.commitPolicy);
+
+  const preLandChecks = Array.isArray(interpreted.preLandChecks) && interpreted.preLandChecks.length > 0
+    ? interpreted.preLandChecks
+    : Object.values(buildCmds);
+
+  const postLandChecks = Array.isArray(interpreted.postLandChecks) && interpreted.postLandChecks.length > 0
+    ? interpreted.postLandChecks
+    : Object.values(testCmds);
+
+  return {
+    ...FALLBACK_CONFIG,
+    ...interpreted,
+    buildCmds,
+    testCmds,
+    commitPolicy,
+    preLandChecks,
+    postLandChecks,
+  };
+}
+
+export default smithers((ctx) => {
+  const runtimeConfig = resolveRuntimeConfig(ctx);
+  const agentSafetyPolicy = resolveAgentSafetyPolicy(runtimeConfig.agentSafetyPolicy);
+  const planningAgent = choose("claude", "Plan and research next tickets.", agentSafetyPolicy);
+  const implementationAgent = choose(
+    "claude",
+    "Implement with test-driven development and jj workflows.",
+    agentSafetyPolicy,
+  );
+  const testingAgent = choose(
+    "claude",
+    "Run tests and validate behavior changes.",
+    agentSafetyPolicy,
+  );
+  const reviewingAgent = choose(
+    "codex",
+    "Review for regressions, spec drift, and correctness.",
+    agentSafetyPolicy,
+  );
+  const reportingAgent = choose(
+    "claude",
+    "Write concise, accurate ticket status reports.",
+    agentSafetyPolicy,
+  );
+
+  return (
+    <Workflow name="super-ralph-full">
+      <Sequence>
+        {/* Step 1: Interpret Config (clarification session already collected by CLI) */}
+        <InterpretConfig
           prompt={PROMPT_TEXT}
+          clarificationSession={CLARIFICATION_SESSION}
           repoRoot={REPO_ROOT}
+          fallbackConfig={FALLBACK_CONFIG}
+          packageScripts={PACKAGE_SCRIPTS}
+          detectedAgents={{
+            claude: HAS_CLAUDE,
+            codex: HAS_CODEX,
+            gh: false,
+          }}
+          agent={planningAgent}
         />
-      </Parallel>
-    </Sequence>
-  </Workflow>
-));
+
+        {/* Step 2: Run SuperRalph + Monitor in Parallel */}
+        <Parallel>
+          <SuperRalph
+            ctx={ctx}
+            outputs={outputs}
+            {...runtimeConfig}
+            agents={{
+              planning: planningAgent,
+              implementation: implementationAgent,
+              testing: testingAgent,
+              reviewing: reviewingAgent,
+              reporting: reportingAgent,
+            }}
+            agentSafetyPolicy={agentSafetyPolicy}
+          />
+
+          <Monitor
+            dbPath={DB_PATH}
+            runId={ctx.runId}
+            config={runtimeConfig}
+            clarificationSession={CLARIFICATION_SESSION}
+            prompt={PROMPT_TEXT}
+            repoRoot={REPO_ROOT}
+          />
+        </Parallel>
+      </Sequence>
+    </Workflow>
+  );
+});
 `;
 }
 
diff --git a/src/components/InterpretConfig.tsx b/src/components/InterpretConfig.tsx
index 77be1f5..f7f8c61 100644
--- a/src/components/InterpretConfig.tsx
+++ b/src/components/InterpretConfig.tsx
@@ -14,14 +14,21 @@ export const interpretConfigOutputSchema = z.object({
   focuses: z.array(focusSchema).min(1).max(12),
   specsPath: z.string().min(1),
   referenceFiles: z.array(z.string()),
-  buildCmds: z.record(z.string(), z.string()),
-  testCmds: z.record(z.string(), z.string()),
-  preLandChecks: z.array(z.string()),
-  postLandChecks: z.array(z.string()),
+  // Avoid emitting JSON Schema `propertyNames` from z.record(...)
+  // because Codex structured output rejects it.
+  buildCmds: z.object({}).catchall(z.string()),
+  testCmds: z.object({}).catchall(z.string()),
+  preLandChecks: z.array(z.string()).min(1),
+  postLandChecks: z.array(z.string()).min(1),
+  commitPolicy: z.object({
+    allowedTypes: z.array(z.string().min(1)).min(1),
+    requireAtomicChecks: z.boolean(),
+  }),
   codeStyle: z.string().min(1),
   reviewChecklist: z.array(z.string()).min(1),
   maxConcurrency: z.number().int().min(1).max(64),
-  reasoning: z.string().optional(),
+  // Codex structured output expects every declared property in `required`.
+  reasoning: z.string(),
 });
 
 export type InterpretConfigOutput = z.infer<typeof interpretConfigOutputSchema>;
@@ -98,6 +105,10 @@ export function InterpretConfig({
         testCmds: { language_or_tool: "command" },
         preLandChecks: ["command"],
         postLandChecks: ["command"],
+        commitPolicy: {
+          allowedTypes: ["feat", "fix", "docs", "chore"],
+          requireAtomicChecks: true,
+        },
         codeStyle: "string",
         reviewChecklist: ["string"],
         maxConcurrency: 8,
@@ -112,6 +123,12 @@ export function InterpretConfig({
     "- Keep focuses concise (2-6).",
     "- Prefer paths relative to repo root.",
     "- Include the user prompt file as a reference when relevant.",
+    "- Gate fields are mandatory: buildCmds, testCmds, preLandChecks, postLandChecks.",
+    "- preLandChecks and postLandChecks must be non-empty arrays.",
+    "- If package scripts include typecheck/test, include both commands in the gate config.",
+    "- commitPolicy is mandatory.",
+    "- Allowed commit types are restricted to feat|fix|docs|chore.",
+    "- requireAtomicChecks must stay true to enforce typecheck + relevant tests before each atomic commit.",
     "- Never return null; omit fields instead.",
     clarificationSession
       ? "- CRITICAL: Interpret and apply the user's clarification answers to tailor the config."
diff --git a/src/components/SuperRalph.tsx b/src/components/SuperRalph.tsx
index 96d1c69..eaf0832 100644
--- a/src/components/SuperRalph.tsx
+++ b/src/components/SuperRalph.tsx
@@ -16,6 +16,16 @@ import CodeReviewPrompt from "../prompts/CodeReview.mdx";
 import ReviewFixPrompt from "../prompts/ReviewFix.mdx";
 import ReportPrompt from "../prompts/Report.mdx";
 import CategoryReviewPrompt from "../prompts/CategoryReview.mdx";
+import { resolveTicketGateSelection } from "./ticket-gates";
+import {
+  normalizeAgentSafetyPolicy,
+  requiresApprovalForPhase,
+  type AgentSafetyPolicy,
+} from "./agent-safety-policy";
+import {
+  assertCommitMessageAllowed,
+  normalizeCommitPolicy,
+} from "./commit-policy";
 import {
   buildSpeculativeMergeQueuePrompt,
   createSpeculativeMergeQueueAgent,
@@ -55,11 +65,18 @@ export type SuperRalphProps = {
 
   // Configuration
   progressFile?: string;
+  progressBookmark?: string;
   findingsFile?: string;
   commitConfig?: {
     prefix?: string;
     mainBranch?: string;
     emojiPrefixes?: string;
+    allowedTypes?: string[];
+    requireAtomicChecks?: boolean;
+  };
+  commitPolicy?: {
+    allowedTypes?: string[];
+    requireAtomicChecks?: boolean;
   };
   testSuites?: Array<{
     name: string;
@@ -79,6 +96,7 @@ export type SuperRalphProps = {
   /** Merge queue id used to isolate coordinator state */
   mergeQueueId?: string;
   skipPhases?: Set<string>;
+  agentSafetyPolicy?: AgentSafetyPolicy;
 
   // Advanced: Override any step with custom component
   updateProgress?: ReactElement;
@@ -149,8 +167,10 @@ export function SuperRalph({
   taskRetries = 3,
   agents,
   progressFile = "PROGRESS.md",
+  progressBookmark = "progress/update-progress",
   findingsFile = "docs/test-suite-findings.md",
   commitConfig = {},
+  commitPolicy: rawCommitPolicy,
   testSuites = [],
   focusTestSuites = {},
   focusDirs = {},
@@ -160,6 +180,7 @@ export function SuperRalph({
   maxSpeculativeDepth = 3,
   mergeQueueId = "land-queue",
   skipPhases = new Set(),
+  agentSafetyPolicy: rawAgentSafetyPolicy,
 
   // Advanced overrides
   updateProgress: customUpdateProgress,
@@ -184,6 +205,14 @@ export function SuperRalph({
   const progressSummary = selectProgressSummary(ctx);
 
   const { prefix = "ðŸ“", mainBranch = "main", emojiPrefixes = "âœ¨ feat, ðŸ› fix, â™»ï¸ refactor, ðŸ“ docs, ðŸ§ª test" } = commitConfig;
+  const commitPolicy = normalizeCommitPolicy(
+    rawCommitPolicy ?? {
+      allowedTypes: commitConfig.allowedTypes,
+      requireAtomicChecks: commitConfig.requireAtomicChecks,
+    },
+  );
+  const progressCommitMessage = "docs: update progress report";
+  assertCommitMessageAllowed(progressCommitMessage, commitPolicy);
 
   const planningAgent = normalizeAgent(agents.planning);
   const implementationAgent = normalizeAgent(agents.implementation);
@@ -193,6 +222,7 @@ export function SuperRalph({
   const mergeQueueAgent = normalizeAgent(
     agents.mergeQueue ?? createSpeculativeMergeQueueAgent(),
   );
+  const agentSafetyPolicy = normalizeAgentSafetyPolicy(rawAgentSafetyPolicy);
 
   const ciCommands = postLandChecks.length > 0 ? postLandChecks : Object.values(testCmds);
 
@@ -229,12 +259,17 @@ export function SuperRalph({
     <Ralph until={false} maxIterations={Infinity} onMaxReached="return-last">
       <Parallel maxConcurrency={maxConcurrency}>
         {!skipPhases.has("PROGRESS") && (customUpdateProgress || (
-          <Worktree id="wt-update-progress" path="/tmp/workflow-wt-update-progress">
+          <Worktree
+            id="wt-update-progress"
+            path="/tmp/workflow-wt-update-progress"
+            branch={progressBookmark}
+          >
             <Task id="update-progress" output={outputs.progress} agent={reportingAgent} retries={taskRetries}>
               <UpdateProgressPrompt
                 projectName={projectName}
                 progressFile={progressFile}
-                commitMessage={`${prefix} docs: update progress`}
+                progressBookmark={progressBookmark}
+                commitMessage={progressCommitMessage}
                 completedTickets={completedTicketIds}
               />
             </Task>
@@ -308,6 +343,13 @@ export function SuperRalph({
           const ticketImplementationAgent = roundRobinAgent(implementationAgent, ticketIndex);
           const ticketTestingAgent = roundRobinAgent(testingAgent, ticketIndex);
           const ticketReportingAgent = roundRobinAgent(reportingAgent, ticketIndex);
+          const ticketGateSelection = resolveTicketGateSelection({
+            ticketId: ticket.id,
+            ticketCategory: ticket.category,
+            buildCmds,
+            testCmds,
+            preLandChecks,
+          });
 
           const mergeQueueRequest: MergeQueueRequest = {
             runId: ctx.runId,
@@ -390,7 +432,16 @@ export function SuperRalph({
                       return (
                         <>
                           {customImplement || (
-                            <Task id={`${ticket.id}:implement`} output={outputs.implement} agent={ticketImplementationAgent} retries={taskRetries}>
+                            <Task
+                              id={`${ticket.id}:implement`}
+                              output={outputs.implement}
+                              agent={ticketImplementationAgent}
+                              retries={taskRetries}
+                              needsApproval={requiresApprovalForPhase(
+                                "implement",
+                                agentSafetyPolicy,
+                              )}
+                            >
                               <ImplementPrompt
                                 ticketId={ticket.id}
                                 ticketTitle={ticket.title}
@@ -405,9 +456,11 @@ export function SuperRalph({
                                 testWritingGuidance={["Write unit tests AND integration tests"]}
                                 implementationGuidance={["Follow architecture patterns from specs"]}
                                 formatterCommands={Object.entries(buildCmds).map(([lang, cmd]) => `Format ${lang}`)}
-                                verifyCommands={Object.values(buildCmds)}
+                                verifyCommands={ticketGateSelection.verifyCommands}
+                                atomicCheckCommands={ticketGateSelection.verifyCommands}
                                 architectureRules={[`Read ${specsPath} for patterns`]}
                                 commitPrefix={prefix}
+                                allowedCommitTypes={commitPolicy.allowedTypes}
                                 mainBranch={mainBranch}
                                 emojiPrefixes={emojiPrefixes}
                               />
@@ -420,11 +473,11 @@ export function SuperRalph({
                                 ticketId={ticket.id}
                                 ticketTitle={ticket.title}
                                 ticketCategory={ticket.category}
-                                testSuites={testSuites.length > 0 ? testSuites : Object.entries(testCmds).map(([name, command]) => ({
-                                  name: `${name} tests`,
-                                  command,
-                                  description: `Run ${name} tests`,
-                                }))}
+                                testSuites={
+                                  testSuites.length > 0
+                                    ? testSuites
+                                    : ticketGateSelection.testSuites
+                                }
                                 fixCommitPrefix={`ðŸ› fix`}
                                 mainBranch={mainBranch}
                               />
@@ -480,7 +533,16 @@ export function SuperRalph({
                           </Parallel>
 
                           {customReviewFix || (!noReviewIssues && (
-                            <Task id={`${ticket.id}:review-fix`} output={outputs.review_fix} agent={ticketImplementationAgent} retries={taskRetries}>
+                            <Task
+                              id={`${ticket.id}:review-fix`}
+                              output={outputs.review_fix}
+                              agent={ticketImplementationAgent}
+                              retries={taskRetries}
+                              needsApproval={requiresApprovalForPhase(
+                                "review-fix",
+                                agentSafetyPolicy,
+                              )}
+                            >
                               <ReviewFixPrompt
                                 ticketId={ticket.id}
                                 ticketTitle={ticket.title}
@@ -491,8 +553,10 @@ export function SuperRalph({
                                 codeSeverity={worstCodeSeverity}
                                 codeFeedback={mergedCodeFeedback}
                                 codeIssues={mergedCodeIssues.length > 0 ? mergedCodeIssues : null}
-                                validationCommands={Object.values(testCmds)}
+                                validationCommands={ticketGateSelection.validationCommands}
+                                atomicCheckCommands={ticketGateSelection.validationCommands}
                                 commitPrefix={`ðŸ› fix`}
+                                allowedCommitTypes={commitPolicy.allowedTypes}
                                 mainBranch={mainBranch}
                                 emojiPrefixes={emojiPrefixes}
                               />
@@ -527,7 +591,16 @@ export function SuperRalph({
               {/* Phase 2: Landing (stateful speculative merge queue coordinator) */}
               <MergeQueue id={mergeQueueId} maxConcurrency={Math.max(1, maxSpeculativeDepth)}>
                 {customLand || (
-                  <Task id={`${ticket.id}:land`} output={outputs.land} agent={mergeQueueAgent} retries={taskRetries}>
+                  <Task
+                    id={`${ticket.id}:land`}
+                    output={outputs.land}
+                    agent={mergeQueueAgent}
+                    retries={taskRetries}
+                    needsApproval={requiresApprovalForPhase(
+                      "land",
+                      agentSafetyPolicy,
+                    )}
+                  >
                     {buildSpeculativeMergeQueuePrompt(mergeQueueRequest)}
                   </Task>
                 )}
diff --git a/src/components/agent-safety-policy.ts b/src/components/agent-safety-policy.ts
new file mode 100644
index 0000000..063bbc4
--- /dev/null
+++ b/src/components/agent-safety-policy.ts
@@ -0,0 +1,71 @@
+const RISKY_PHASES = ["implement", "review-fix", "land"] as const;
+
+type RiskyPhase = (typeof RISKY_PHASES)[number];
+
+export type AgentSafetyPolicy = {
+  riskyModeEnabled: boolean;
+  approvalRequiredPhases: string[];
+};
+
+function toRiskyPhase(phase: unknown): RiskyPhase | null {
+  if (typeof phase !== "string") return null;
+
+  const normalized = phase.trim().toLowerCase();
+  if (normalized.length === 0) return null;
+
+  return RISKY_PHASES.includes(normalized as RiskyPhase)
+    ? (normalized as RiskyPhase)
+    : null;
+}
+
+export function normalizeAgentSafetyPolicy(input: unknown): AgentSafetyPolicy {
+  if (!input || typeof input !== "object") {
+    return {
+      riskyModeEnabled: false,
+      approvalRequiredPhases: [],
+    };
+  }
+
+  const raw = input as {
+    riskyModeEnabled?: unknown;
+    approvalRequiredPhases?: unknown;
+  };
+
+  if (raw.riskyModeEnabled !== true) {
+    return {
+      riskyModeEnabled: false,
+      approvalRequiredPhases: [],
+    };
+  }
+
+  const requested = Array.isArray(raw.approvalRequiredPhases)
+    ? raw.approvalRequiredPhases
+    : [];
+  const approvalRequiredPhases: RiskyPhase[] = [];
+
+  for (const phase of requested) {
+    const normalized = toRiskyPhase(phase);
+    if (!normalized || approvalRequiredPhases.includes(normalized)) continue;
+    approvalRequiredPhases.push(normalized);
+  }
+
+  return {
+    riskyModeEnabled: true,
+    approvalRequiredPhases:
+      approvalRequiredPhases.length > 0
+        ? approvalRequiredPhases
+        : [...RISKY_PHASES],
+  };
+}
+
+export function requiresApprovalForPhase(
+  phase: string,
+  policy: AgentSafetyPolicy,
+): boolean {
+  if (policy.riskyModeEnabled !== true) return false;
+
+  const normalizedPhase = toRiskyPhase(phase);
+  if (!normalizedPhase) return false;
+
+  return policy.approvalRequiredPhases.includes(normalizedPhase);
+}
diff --git a/src/components/commit-policy.ts b/src/components/commit-policy.ts
new file mode 100644
index 0000000..950db56
--- /dev/null
+++ b/src/components/commit-policy.ts
@@ -0,0 +1,83 @@
+export const DEFAULT_ALLOWED_COMMIT_TYPES = [
+  "feat",
+  "fix",
+  "docs",
+  "chore",
+] as const;
+
+export type CommitPolicy = {
+  allowedTypes: string[];
+  requireAtomicChecks: boolean;
+};
+
+export function parseCommitType(commitMessage: string): string | null {
+  if (typeof commitMessage !== "string") return null;
+  const normalized = commitMessage.trim();
+  if (normalized.length === 0) return null;
+
+  const match = normalized.match(
+    /^([a-z]+)(?:\([a-z0-9._/-]+\))?(?:!)?:\s+\S/i,
+  );
+  if (!match) return null;
+  return match[1].toLowerCase();
+}
+
+export function normalizeCommitPolicy(input: unknown): CommitPolicy {
+  const fallbackAllowedTypes = [...DEFAULT_ALLOWED_COMMIT_TYPES];
+  if (!input || typeof input !== "object") {
+    return {
+      allowedTypes: fallbackAllowedTypes,
+      requireAtomicChecks: true,
+    };
+  }
+
+  const candidate = input as {
+    allowedTypes?: unknown;
+    requireAtomicChecks?: unknown;
+  };
+
+  const dedupedAllowedTypes: string[] = [];
+  const seen = new Set<string>();
+  if (Array.isArray(candidate.allowedTypes)) {
+    for (const rawType of candidate.allowedTypes) {
+      if (typeof rawType !== "string") continue;
+      const normalizedType = rawType.trim().toLowerCase();
+      if (!/^[a-z]+$/.test(normalizedType)) continue;
+      if (seen.has(normalizedType)) continue;
+      seen.add(normalizedType);
+      dedupedAllowedTypes.push(normalizedType);
+    }
+  }
+
+  return {
+    allowedTypes:
+      dedupedAllowedTypes.length > 0
+        ? dedupedAllowedTypes
+        : fallbackAllowedTypes,
+    requireAtomicChecks:
+      typeof candidate.requireAtomicChecks === "boolean"
+        ? candidate.requireAtomicChecks
+        : true,
+  };
+}
+
+export function assertCommitMessageAllowed(
+  commitMessage: string,
+  policy: CommitPolicy,
+): void {
+  const commitType = parseCommitType(commitMessage);
+  if (!commitType) {
+    throw new Error(
+      "Commit message must use conventional commit format: type(scope): description",
+    );
+  }
+
+  const allowedTypes = normalizeCommitPolicy(policy).allowedTypes;
+  if (!allowedTypes.includes(commitType)) {
+    throw new Error(
+      `Commit type "${commitType}" is not allowed. Allowed commit types: ${allowedTypes.join(
+        ", ",
+      )}`,
+    );
+  }
+}
diff --git a/src/components/index.ts b/src/components/index.ts
index f39fc15..9261dcb 100644
--- a/src/components/index.ts
+++ b/src/components/index.ts
@@ -1,5 +1,10 @@
 export { SuperRalph } from "./SuperRalph";
 export type { SuperRalphProps } from "./SuperRalph";
+export {
+  normalizeAgentSafetyPolicy,
+  requiresApprovalForPhase,
+} from "./agent-safety-policy";
+export type { AgentSafetyPolicy } from "./agent-safety-policy";
 
 export { ClarifyingQuestions, clarifyingQuestionsOutputSchema, generateQuestionsOutputSchema } from "./ClarifyingQuestions";
 export type { ClarifyingQuestionsOutput, ClarifyingQuestionsProps } from "./ClarifyingQuestions";
@@ -9,3 +14,11 @@ export type { InterpretConfigOutput, InterpretConfigProps } from "./InterpretCon
 
 export { Monitor, monitorOutputSchema } from "./Monitor";
 export type { MonitorOutput, MonitorProps } from "./Monitor";
+
+export {
+  type CommitPolicy,
+  assertCommitMessageAllowed,
+  DEFAULT_ALLOWED_COMMIT_TYPES,
+  normalizeCommitPolicy,
+  parseCommitType,
+} from "./commit-policy";
diff --git a/src/components/ticket-gates.ts b/src/components/ticket-gates.ts
new file mode 100644
index 0000000..279aa9e
--- /dev/null
+++ b/src/components/ticket-gates.ts
@@ -0,0 +1,171 @@
+export type ResolveTicketGateSelectionParams = {
+  ticketId?: string;
+  ticketCategory: string;
+  buildCmds: Record<string, string>;
+  testCmds: Record<string, string>;
+  preLandChecks: string[];
+};
+
+export type TicketGateSelection = {
+  verifyCommands: string[];
+  validationCommands: string[];
+  testSuites: Array<{
+    name: string;
+    command: string;
+    description: string;
+  }>;
+};
+
+const NON_RUNNABLE_GATE_PATTERNS = [/No .* configured yet/i, /\|\|\s*echo\b/i, /^echo\b/i];
+
+function normalizeCategory(ticketCategory: string, ticketId?: string): string {
+  const normalized = ticketCategory.trim().toLowerCase();
+  const normalizedId = (ticketId ?? "").trim().toUpperCase();
+  if (!normalized) return "default";
+
+  if (normalized.includes("workflow")) return "workflow";
+  if (normalized.includes("api")) return "api";
+  if (normalized.includes("db") || normalized.includes("data")) return "db";
+  if (normalized.includes("core")) return "core";
+  if (normalized.includes("test")) {
+    if (normalizedId.startsWith("API-")) return "api";
+    if (normalizedId.startsWith("DB-") || normalizedId.startsWith("DATA-")) return "db";
+  }
+  return normalized;
+}
+
+function toRunnableCommand(command: string | undefined): string | null {
+  if (typeof command !== "string") return null;
+  const normalized = command.trim();
+  if (!normalized) return null;
+
+  for (const pattern of NON_RUNNABLE_GATE_PATTERNS) {
+    if (pattern.test(normalized)) {
+      return null;
+    }
+  }
+
+  return normalized;
+}
+
+function uniqueCommands(commands: string[]): string[] {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+
+  for (const command of commands) {
+    const normalized = command.trim();
+    if (!normalized || seen.has(normalized)) continue;
+    if (!toRunnableCommand(normalized)) {
+      throw new Error(`Resolved non-runnable gate command: ${normalized}`);
+    }
+    seen.add(normalized);
+    unique.push(normalized);
+  }
+
+  if (unique.length === 0) {
+    throw new Error("Resolved non-runnable gate command: no runnable commands found");
+  }
+
+  return unique;
+}
+
+function assertAtomicCheckDiscipline(commands: string[]): void {
+  const hasTypecheckCommand = commands.some((command) =>
+    /\btypecheck\b/i.test(command),
+  );
+  if (!hasTypecheckCommand) {
+    throw new Error(
+      "Atomic check discipline violation: verify commands must include a runnable typecheck command",
+    );
+  }
+
+  const hasRunnableTestCommand = commands.some(
+    (command) => /\btest\b/i.test(command) && !/\btypecheck\b/i.test(command),
+  );
+  if (!hasRunnableTestCommand) {
+    throw new Error(
+      "Atomic check discipline violation: verify commands must include a runnable test command",
+    );
+  }
+}
+
+function defaultTestCommand(testCmds: Record<string, string>): string {
+  const preferred = toRunnableCommand(testCmds.test);
+  if (preferred) return preferred;
+
+  throw new Error("No runnable test command configured for ticket gates");
+}
+
+export const resolveCategoryTestCommand = (
+  ticketCategory: string,
+  testCmds: Record<string, string>,
+  ticketId?: string,
+): string => {
+  const normalizedCategory = normalizeCategory(ticketCategory, ticketId);
+
+  const categoryCommand = normalizedCategory === "core"
+    ? testCmds.core
+    : normalizedCategory === "api"
+      ? testCmds.api
+      : normalizedCategory === "workflow"
+        ? testCmds.workflow
+        : normalizedCategory === "db"
+          ? testCmds.db
+          : undefined;
+
+  const runnableCategoryCommand = toRunnableCommand(categoryCommand);
+  if (runnableCategoryCommand) return runnableCategoryCommand;
+
+  return defaultTestCommand(testCmds);
+};
+
+export const resolveVerifyCommands = (params: ResolveTicketGateSelectionParams): string[] => {
+  const { ticketId, ticketCategory, buildCmds, testCmds, preLandChecks } = params;
+  const categoryTestCommand = resolveCategoryTestCommand(
+    ticketCategory,
+    testCmds,
+    ticketId,
+  );
+
+  const candidateChecks = preLandChecks.length > 0
+    ? [...preLandChecks]
+    : [buildCmds.typecheck ?? Object.values(buildCmds)[0] ?? ""];
+
+  if (buildCmds.typecheck && !candidateChecks.includes(buildCmds.typecheck)) {
+    candidateChecks.unshift(buildCmds.typecheck);
+  }
+
+  candidateChecks.push(categoryTestCommand);
+  const verifyCommands = uniqueCommands(candidateChecks);
+  if (verifyCommands.length === 0) {
+    throw new Error("Resolved non-runnable gate command: no verify commands");
+  }
+  assertAtomicCheckDiscipline(verifyCommands);
+
+  return verifyCommands;
+};
+
+export const resolveTicketGateSelection = (
+  params: ResolveTicketGateSelectionParams,
+): TicketGateSelection => {
+  const normalizedCategory = normalizeCategory(params.ticketCategory, params.ticketId);
+  const testCommand = resolveCategoryTestCommand(
+    params.ticketCategory,
+    params.testCmds,
+    params.ticketId,
+  );
+  const verifyCommands = resolveVerifyCommands(params);
+  const validationCommands = uniqueCommands([...verifyCommands]);
+
+  return {
+    verifyCommands,
+    validationCommands,
+    testSuites: [
+      {
+        name: `${normalizedCategory} tests`,
+        command: testCommand,
+        description: `Run ${normalizedCategory} tests`,
+      },
+    ],
+  };
+};
diff --git a/src/mergeQueue/coordinator.ts b/src/mergeQueue/coordinator.ts
index 4a8450a..bab6f27 100644
--- a/src/mergeQueue/coordinator.ts
+++ b/src/mergeQueue/coordinator.ts
@@ -101,8 +101,13 @@ export type MergeQueueRequest = {
 
 const REQUEST_MARKER = "SUPER_RALPH_SPECULATIVE_MERGE_QUEUE_REQUEST";
 
-function bookmarkRev(ticketId: string): string {
-  return `bookmark("ticket/${ticketId}")`;
+function escapeRevsetString(value: string): string {
+  return value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
+}
+
+function ticketBookmarkRevset(ticketId: string): string {
+  const escapedTicketId = escapeRevsetString(ticketId);
+  return `bookmarks("ticket/${escapedTicketId}")`;
 }
 
 function truncate(text: string, maxChars = 12000): string {
@@ -172,7 +177,7 @@ async function runCiInSpeculativeWorkspace(
   try {
     const added = await workspaceAdd(workspaceName, workspacePath, {
       cwd: repoRoot,
-      atRev: bookmarkRev(ticket.ticketId),
+      atRev: ticketBookmarkRevset(ticket.ticketId),
     });
     if (!added.success) {
       return {
@@ -207,19 +212,19 @@ async function collectDefaultEvictionContext(
   const attemptedLog = await runJjCommand(repoRoot, [
     "log",
     "-r",
-    `main..${bookmarkRev(ticketId)}`,
+    `main..${ticketBookmarkRevset(ticketId)}`,
     "--reversed",
   ]);
   const attemptedDiff = await runJjCommand(repoRoot, [
     "diff",
     "-r",
-    `roots(main..${bookmarkRev(ticketId)})`,
+    `roots(main..${ticketBookmarkRevset(ticketId)})`,
     "--summary",
   ]);
   const landedOnMain = await runJjCommand(repoRoot, [
     "log",
     "-r",
-    `${bookmarkRev(ticketId)}..main`,
+    `${ticketBookmarkRevset(ticketId)}..main`,
     "--reversed",
   ]);
 
@@ -261,7 +266,7 @@ export function createDefaultMergeQueueOps(): MergeQueueOps {
         await runJjCommand(repoRoot, [
           "rebase",
           "-b",
-          bookmarkRev(ticketId),
+          ticketBookmarkRevset(ticketId),
           "-d",
           destinationRev,
         ]),
@@ -278,7 +283,7 @@ export function createDefaultMergeQueueOps(): MergeQueueOps {
           "set",
           "main",
           "-r",
-          bookmarkRev(ticketId),
+          ticketBookmarkRevset(ticketId),
         ]),
       );
     },
@@ -554,7 +559,7 @@ export class SpeculativeMergeQueueCoordinator {
     for (const entry of entries) {
       const commit = await this.ops.readCommitId(
         this.repoRoot,
-        bookmarkRev(entry.ticket.ticketId),
+        ticketBookmarkRevset(entry.ticket.ticketId),
       );
       const retestNote =
         entry.invalidatedCount > 0
diff --git a/src/prompts/BuildVerify.mdx b/src/prompts/BuildVerify.mdx
index 66f7a40..41f4472 100644
--- a/src/prompts/BuildVerify.mdx
+++ b/src/prompts/BuildVerify.mdx
@@ -23,6 +23,8 @@ This is the equivalent of a full CI build check.
 Fix compilation errors immediately:
 1. Read the error output carefully
 2. Fix the root cause (not just the symptom)
-3. Commit fixes atomically: `jj describe -m "{props.fixCommitPrefix || 'ðŸ› fix'}(scope): fix compilation error in X"` then `jj new`
-4. After fixing: `jj bookmark set ticket/{props.ticketId} -r @` && `jj git push --bookmark ticket/{props.ticketId}`
-5. Re-run the build to verify
+3. Use only allowed commit types: feat|fix|docs|chore.
+4. Before each atomic `jj describe`, run typecheck + relevant tests for the fix.
+5. Commit fixes atomically: `jj describe -m "<allowed-type>(scope): fix compilation error in X"` then `jj new`
+6. After fixing: `jj bookmark set ticket/{props.ticketId} -r @` && `jj git push --bookmark ticket/{props.ticketId}`
+7. Re-run the build to verify
diff --git a/src/prompts/Implement.mdx b/src/prompts/Implement.mdx
index ea83b15..0121bdc 100644
--- a/src/prompts/Implement.mdx
+++ b/src/prompts/Implement.mdx
@@ -58,11 +58,22 @@ Implementation steps from plan:
 
 You MUST commit and push your changes to the ticket branch before finishing. Uncommitted work is lost work.
 
-1. `jj describe -m "{props.commitPrefix || 'EMOJI'} type(scope): description"` â€” describe your changes with a meaningful message.
-2. `jj new` â€” create a new change for the next logical step. Repeat describe+new for each atomic change.
-3. `jj bookmark set ticket/{props.ticketId} -r @`
-4. `jj git push --bookmark ticket/{props.ticketId}`
-
-{props.emojiPrefixes ? `Emoji prefixes: ${props.emojiPrefixes}` : 'Use conventional commit prefixes'}
+Use only allowed commit types: feat|fix|docs|chore.
+{props.allowedCommitTypes && props.allowedCommitTypes.length > 0
+  ? `Configured allowed commit types: ${props.allowedCommitTypes.join('|')}`
+  : ''}
+
+Before each atomic `jj describe`, run these required checks:
+{props.atomicCheckCommands && props.atomicCheckCommands.length > 0
+  ? props.atomicCheckCommands.map(c => `- \`${c}\``).join('\n')
+  : props.verifyCommands && props.verifyCommands.length > 0
+    ? props.verifyCommands.map(c => `- \`${c}\``).join('\n')
+    : '- Run typecheck and relevant tests'}
+
+1. `jj describe -m "<allowed-type>(scope): concise description"` â€” describe exactly one atomic slice.
+2. `jj new` â€” create a new change for the next atomic slice.
+3. Repeat check + describe + new for each atomic change.
+4. `jj bookmark set ticket/{props.ticketId} -r @`
+5. `jj git push --bookmark ticket/{props.ticketId}`
 
 **If you do not commit and push to the ticket branch, your work does not count. This is non-negotiable.**
diff --git a/src/prompts/Land.mdx b/src/prompts/Land.mdx
index e665f25..0401efa 100644
--- a/src/prompts/Land.mdx
+++ b/src/prompts/Land.mdx
@@ -19,8 +19,8 @@ jj git fetch
 Before rebasing, check what other tickets landed on main since this branch diverged. This helps you catch **semantic conflicts** (code that doesn't cause git conflicts but breaks at runtime â€” e.g. renamed functions, changed signatures, moved files, altered behavior your code depends on).
 
 ```
-jj log -r 'main..bookmark("ticket/{props.ticketId}")' --reversed
-jj diff -r 'roots(main..bookmark("ticket/{props.ticketId}"))' --summary
+jj log -r 'main..bookmarks("ticket/{props.ticketId}")' --reversed
+jj diff -r 'roots(main..bookmarks("ticket/{props.ticketId}"))' --summary
 ```
 
 Review the log and diff carefully. If other tickets modified files or APIs that your branch also touches, check for:
@@ -33,7 +33,7 @@ Review the log and diff carefully. If other tickets modified files or APIs that
 ### Step 3: Rebase branch onto latest main
 
 ```
-jj rebase -b 'bookmark("ticket/{props.ticketId}") ' -d main
+jj rebase -b 'bookmarks("ticket/{props.ticketId}") ' -d main
 ```
 
 If there are explicit conflicts, resolve them and describe the resolution.
@@ -56,7 +56,7 @@ If CI fails, output `{ "merged": false, "mergeCommit": null, "ciPassed": false,
 
 If CI passes:
 ```
-jj bookmark set main -r 'bookmark("ticket/{props.ticketId}")'
+jj bookmark set main -r 'bookmarks("ticket/{props.ticketId}")'
 ```
 
 ### Step 6: Push main
diff --git a/src/prompts/Plan.mdx b/src/prompts/Plan.mdx
index b589e38..f20670e 100644
--- a/src/prompts/Plan.mdx
+++ b/src/prompts/Plan.mdx
@@ -45,7 +45,9 @@ The plan file MUST follow TDD ordering:
 
 After writing the plan file:
 ```
-jj describe -m "{props.commitPrefix || 'ðŸ“'} docs({props.ticketCategory}): create plan for {props.ticketId}"
+Use only allowed commit types: feat|fix|docs|chore.
+This phase should use docs commits unless code changes are required.
+jj describe -m "docs({props.ticketCategory}): create plan for {props.ticketId}"
 jj new
 jj bookmark set ticket/{props.ticketId} -r @
 jj git push --bookmark ticket/{props.ticketId}
diff --git a/src/prompts/Research.mdx b/src/prompts/Research.mdx
index 7ca7698..b440979 100644
--- a/src/prompts/Research.mdx
+++ b/src/prompts/Research.mdx
@@ -27,7 +27,9 @@ Your job is to gather all reference materials needed to implement this ticket.
 
 After writing the context file:
 ```
-jj describe -m "ðŸ“ docs({props.ticketCategory}): gather research for {props.ticketId}"
+Use only allowed commit types: feat|fix|docs|chore.
+This phase should use docs commits unless code changes are required.
+jj describe -m "docs({props.ticketCategory}): gather research for {props.ticketId}"
 jj new
 jj bookmark set ticket/{props.ticketId} -r @
 jj git push --bookmark ticket/{props.ticketId}
diff --git a/src/prompts/ReviewFix.mdx b/src/prompts/ReviewFix.mdx
index 1b3fae7..fd2d35e 100644
--- a/src/prompts/ReviewFix.mdx
+++ b/src/prompts/ReviewFix.mdx
@@ -39,11 +39,22 @@ If a fix requires new behavior:
 
 You MUST commit and push your changes to the ticket branch before finishing. Uncommitted work is lost work.
 
-1. `jj describe -m "{props.commitPrefix || 'EMOJI'} type(scope): description"` â€” describe each fix separately.
+Use only allowed commit types: feat|fix|docs|chore.
+{props.allowedCommitTypes && props.allowedCommitTypes.length > 0
+  ? `Configured allowed commit types: ${props.allowedCommitTypes.join('|')}`
+  : ''}
+
+Before each atomic `jj describe`, run these required checks:
+{props.atomicCheckCommands && props.atomicCheckCommands.length > 0
+  ? props.atomicCheckCommands.map(c => `- \`${c}\``).join('\n')
+  : props.validationCommands && props.validationCommands.length > 0
+    ? props.validationCommands.map(c => `- \`${c}\``).join('\n')
+    : '- Run typecheck and relevant tests'}
+
+1. `jj describe -m "<allowed-type>(scope): concise fix description"` â€” describe each fix separately.
 2. `jj new` â€” create a new change for the next fix. Do NOT batch all fixes into one change.
-3. `jj bookmark set ticket/{props.ticketId} -r @`
-4. `jj git push --bookmark ticket/{props.ticketId}`
-
-{props.emojiPrefixes ? `Emoji prefixes: ${props.emojiPrefixes}` : 'Use conventional commit prefixes'}
+3. Repeat check + describe + new for each atomic fix.
+4. `jj bookmark set ticket/{props.ticketId} -r @`
+5. `jj git push --bookmark ticket/{props.ticketId}`
 
 **If you do not commit and push to the ticket branch, your work does not count. This is non-negotiable.**
diff --git a/src/prompts/Test.mdx b/src/prompts/Test.mdx
index 811cc79..1187453 100644
--- a/src/prompts/Test.mdx
+++ b/src/prompts/Test.mdx
@@ -15,7 +15,9 @@ Run ALL of the following test categories and report results:
 - If tests were written AFTER implementation (not TDD), flag as an issue
 
 If any tests fail and you need to fix code to make them pass, commit each fix atomically:
-- `jj describe -m "{props.fixCommitPrefix || 'ðŸ› fix'}(SCOPE): what was fixed"`
+- Use only allowed commit types: feat|fix|docs|chore.
+- Before each atomic `jj describe`, run typecheck + relevant tests for the fix.
+- `jj describe -m "<allowed-type>(scope): what was fixed"`
 - `jj new`
 - After fixing: `jj bookmark set ticket/{props.ticketId} -r @` && `jj git push --bookmark ticket/{props.ticketId}`
 
diff --git a/src/prompts/UpdateProgress.mdx b/src/prompts/UpdateProgress.mdx
index 7626ebb..f7d4718 100644
--- a/src/prompts/UpdateProgress.mdx
+++ b/src/prompts/UpdateProgress.mdx
@@ -22,9 +22,15 @@ Do NOT run build commands, test commands, or compilation. Those are expensive an
 
 ## Commit
 
-After updating, commit your changes in this worktree:
+After updating, create a bookmark-visible checkpoint in this worktree:
 ```
-jj describe -m "{props.commitMessage || 'ðŸ“ docs: update progress report'}"
+Use only allowed commit types: feat|fix|docs|chore.
+This phase should use docs commits because it updates project progress artifacts.
+jj describe -m "{props.commitMessage || 'docs: update progress report'}"
+jj bookmark set {props.progressBookmark || 'progress/update-progress'} -r @
+jj new
+jj git push --bookmark {props.progressBookmark || 'progress/update-progress'}
+jj log -r 'ancestors(bookmarks("{props.progressBookmark || 'progress/update-progress'}")) & @-' --no-graph -T commit_id
 ```
 
-Do NOT run `jj bookmark set main` or `jj git push` â€” landing is handled separately.
+Do NOT update `main` in this phase. Only update and push the progress bookmark so checkpoints stay auditable.
