diff --git a/package.json b/package.json
index 2368a78..093cbea 100644
--- a/package.json
+++ b/package.json
@@ -13,7 +13,11 @@
     ".": "./src/index.ts",
     "./selectors": "./src/selectors.ts",
     "./components": "./src/components/index.ts",
-    "./cli/clarifications": "./src/cli/clarifications.ts"
+    "./schemas": "./src/schemas.ts",
+    "./gate-config": "./src/cli/gate-config.ts",
+    "./ticket-gates": "./src/components/ticket-gates.ts",
+    "./cli/clarifications": "./src/cli/clarifications.ts",
+    "./cli/fallback-config": "./src/cli/fallback-config.ts"
   },
   "files": [
     "src/",
diff --git a/src/cli/fallback-config.ts b/src/cli/fallback-config.ts
new file mode 100644
index 0000000..69b666e
--- /dev/null
+++ b/src/cli/fallback-config.ts
@@ -0,0 +1,106 @@
+import { existsSync } from "node:fs";
+import { basename, join } from "node:path";
+
+import {
+  buildGateCommandConfig,
+  type ScriptRunner,
+} from "./gate-config";
+
+function hasScript(packageScripts: Record<string, string>, scriptName: string): boolean {
+  const command = packageScripts[scriptName];
+  return typeof command === "string" && command.trim().length > 0;
+}
+
+export function detectScriptRunner(repoRoot: string): ScriptRunner {
+  if (existsSync(join(repoRoot, "bun.lock")) || existsSync(join(repoRoot, "bun.lockb"))) return "bun";
+  if (existsSync(join(repoRoot, "pnpm-lock.yaml"))) return "pnpm";
+  if (existsSync(join(repoRoot, "yarn.lock"))) return "yarn";
+  return "npm";
+}
+
+function slugify(value: string): string {
+  return value
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, "-")
+    .replace(/^-+|-+$/g, "") || "project";
+}
+
+export function buildFallbackConfig(
+  repoRoot: string,
+  promptSpecPath: string,
+  packageScripts: Record<string, string>,
+) {
+  const runner = detectScriptRunner(repoRoot);
+  const hasNodeGateScripts = hasScript(packageScripts, "test") && hasScript(packageScripts, "typecheck");
+  const buildCmds: Record<string, string> = {};
+  const testCmds: Record<string, string> = {};
+
+  if (hasNodeGateScripts) {
+    const gateConfig = buildGateCommandConfig(runner, packageScripts);
+    Object.assign(buildCmds, gateConfig.buildCmds);
+    Object.assign(testCmds, gateConfig.testCmds);
+  }
+
+  if (existsSync(join(repoRoot, "go.mod"))) {
+    buildCmds.go = buildCmds.go ?? "go build ./...";
+    testCmds.go = testCmds.go ?? "go test ./...";
+  }
+
+  if (existsSync(join(repoRoot, "Cargo.toml"))) {
+    buildCmds.rust = buildCmds.rust ?? "cargo build";
+    testCmds.rust = testCmds.rust ?? "cargo test";
+  }
+
+  if (Object.keys(buildCmds).length === 0 || Object.keys(testCmds).length === 0) {
+    throw new Error(
+      "Unable to derive runnable gate commands. Configure package.json test/typecheck scripts or provide Go/Rust project files.",
+    );
+  }
+
+  const specsPathCandidates = [
+    join(repoRoot, "docs/specs/engineering.md"),
+    join(repoRoot, "docs/specs"),
+    join(repoRoot, "specs"),
+    promptSpecPath,
+  ];
+
+  const chosenSpecs = specsPathCandidates.find((candidate) => existsSync(candidate)) ?? promptSpecPath;
+
+  const projectName = basename(repoRoot);
+  const maxConcurrency = Math.min(
+    Math.max(Number(process.env.WORKFLOW_MAX_CONCURRENCY ?? "6") || 6, 1),
+    32,
+  );
+
+  return {
+    projectName,
+    projectId: slugify(projectName),
+    focuses: [
+      { id: "core", name: "Core Platform" },
+      { id: "api", name: "API and Data" },
+      { id: "workflow", name: "Workflow and Automation" },
+    ],
+    specsPath: chosenSpecs,
+    referenceFiles: [
+      promptSpecPath,
+      existsSync(join(repoRoot, "README.md")) ? "README.md" : "",
+      existsSync(join(repoRoot, "docs")) ? "docs" : "",
+    ].filter(Boolean),
+    buildCmds,
+    testCmds,
+    agentSafetyPolicy: {
+      riskyModeEnabled: false,
+      approvalRequiredPhases: [],
+    },
+    preLandChecks: Object.values(buildCmds),
+    postLandChecks: Object.values(testCmds),
+    codeStyle: "Follow existing project conventions and keep changes minimal and test-driven.",
+    reviewChecklist: [
+      "Spec compliance",
+      "Tests cover behavior changes",
+      "No regression risk in existing flows",
+      "Error handling and observability",
+    ],
+    maxConcurrency,
+  };
+}
diff --git a/src/cli/gate-config.ts b/src/cli/gate-config.ts
new file mode 100644
index 0000000..23febe5
--- /dev/null
+++ b/src/cli/gate-config.ts
@@ -0,0 +1,92 @@
+export type ScriptRunner = "bun" | "pnpm" | "yarn" | "npm";
+
+export type GateCommandConfig = {
+  buildCmds: Record<string, string>;
+  testCmds: Record<string, string>;
+  preLandChecks: string[];
+  postLandChecks: string[];
+};
+
+const REQUIRED_GATE_SCRIPTS = ["test", "typecheck"] as const;
+
+function hasScript(packageScripts: Record<string, string>, scriptName: string): boolean {
+  const command = packageScripts[scriptName];
+  return typeof command === "string" && command.trim().length > 0;
+}
+
+function scriptCommand(runner: ScriptRunner, scriptName: string): string {
+  if (runner === "bun") return `bun run ${scriptName}`;
+  if (runner === "pnpm") return `pnpm run ${scriptName}`;
+  if (runner === "yarn") return `yarn ${scriptName}`;
+  return `npm run ${scriptName}`;
+}
+
+function firstExistingScript(packageScripts: Record<string, string>, candidates: string[]): string | null {
+  for (const scriptName of candidates) {
+    if (hasScript(packageScripts, scriptName)) {
+      return scriptName;
+    }
+  }
+
+  return null;
+}
+
+export const assertRequiredGateScripts = (packageScripts: Record<string, string>): void => {
+  const missingScripts = REQUIRED_GATE_SCRIPTS.filter((scriptName) => !hasScript(packageScripts, scriptName));
+
+  if (missingScripts.length > 0) {
+    throw new Error(`Missing required package scripts: ${missingScripts.join(", ")}`);
+  }
+};
+
+export const resolveFocusTestCommands = (
+  runner: ScriptRunner,
+  packageScripts: Record<string, string>,
+): Record<string, string> => {
+  const testCmds: Record<string, string> = {
+    test: scriptCommand(runner, "test"),
+  };
+
+  const focusScriptCandidates: Record<string, string[]> = {
+    core: ["test:core", "test:unit:core", "test:integration:core"],
+    api: ["test:integration:api", "test:api"],
+    workflow: ["test:integration:workflow", "test:workflow"],
+    db: ["test:integration:db", "test:db"],
+  };
+
+  for (const [focus, candidates] of Object.entries(focusScriptCandidates)) {
+    const selectedScript = firstExistingScript(packageScripts, candidates);
+    if (selectedScript) {
+      testCmds[focus] = scriptCommand(runner, selectedScript);
+    }
+  }
+
+  return testCmds;
+};
+
+export const buildGateCommandConfig = (
+  runner: ScriptRunner,
+  packageScripts: Record<string, string>,
+): GateCommandConfig => {
+  assertRequiredGateScripts(packageScripts);
+
+  const buildCmds: Record<string, string> = {
+    typecheck: scriptCommand(runner, "typecheck"),
+  };
+
+  if (hasScript(packageScripts, "build")) {
+    buildCmds.build = scriptCommand(runner, "build");
+  }
+  if (hasScript(packageScripts, "lint")) {
+    buildCmds.lint = scriptCommand(runner, "lint");
+  }
+
+  const testCmds = resolveFocusTestCommands(runner, packageScripts);
+
+  return {
+    buildCmds,
+    testCmds,
+    preLandChecks: Object.values(buildCmds),
+    postLandChecks: Object.values(testCmds),
+  };
+};
diff --git a/src/cli/index.ts b/src/cli/index.ts
old mode 100755
new mode 100644
index 633e857..a41b660
--- a/src/cli/index.ts
+++ b/src/cli/index.ts
@@ -18,9 +18,10 @@
 
 import { existsSync } from "node:fs";
 import { mkdir, readFile, writeFile } from "node:fs/promises";
-import { basename, dirname, join, resolve } from "node:path";
+import { dirname, join, resolve } from "node:path";
 import { fileURLToPath } from "node:url";
 import { randomUUID } from "node:crypto";
+import { buildFallbackConfig } from "./fallback-config";
 
 type ParsedArgs = {
   positional: string[];
@@ -113,27 +114,6 @@ async function loadPackageScripts(repoRoot: string): Promise<Record<string, stri
   }
 }
 
-function detectScriptRunner(repoRoot: string): "bun" | "pnpm" | "yarn" | "npm" {
-  if (existsSync(join(repoRoot, "bun.lock")) || existsSync(join(repoRoot, "bun.lockb"))) return "bun";
-  if (existsSync(join(repoRoot, "pnpm-lock.yaml"))) return "pnpm";
-  if (existsSync(join(repoRoot, "yarn.lock"))) return "yarn";
-  return "npm";
-}
-
-function scriptCommand(runner: "bun" | "pnpm" | "yarn" | "npm", scriptName: string): string {
-  if (runner === "bun") return `bun run ${scriptName}`;
-  if (runner === "pnpm") return `pnpm run ${scriptName}`;
-  if (runner === "yarn") return `yarn ${scriptName}`;
-  return `npm run ${scriptName}`;
-}
-
-function slugify(value: string): string {
-  return value
-    .toLowerCase()
-    .replace(/[^a-z0-9]+/g, "-")
-    .replace(/^-+|-+$/g, "") || "project";
-}
-
 async function commandExists(command: string, cwd: string): Promise<boolean> {
   try {
     const proc = Bun.spawn(["which", command], { cwd, stdout: "pipe", stderr: "pipe" });
@@ -154,85 +134,6 @@ async function detectAgents(repoRoot: string): Promise<{ claude: boolean; codex:
   return { claude, codex, gh };
 }
 
-function buildFallbackConfig(repoRoot: string, promptSpecPath: string, packageScripts: Record<string, string>) {
-  const runner = detectScriptRunner(repoRoot);
-
-  const buildCmds: Record<string, string> = {};
-  const testCmds: Record<string, string> = {};
-
-  if (packageScripts.typecheck) {
-    buildCmds.typecheck = scriptCommand(runner, "typecheck");
-  }
-  if (packageScripts.build) {
-    buildCmds.build = scriptCommand(runner, "build");
-  }
-  if (packageScripts.lint) {
-    buildCmds.lint = scriptCommand(runner, "lint");
-  }
-
-  if (packageScripts.test) {
-    testCmds.test = scriptCommand(runner, "test");
-  }
-
-  if (existsSync(join(repoRoot, "go.mod"))) {
-    buildCmds.go = buildCmds.go ?? "go build ./...";
-    testCmds.go = testCmds.go ?? "go test ./...";
-  }
-
-  if (existsSync(join(repoRoot, "Cargo.toml"))) {
-    buildCmds.rust = buildCmds.rust ?? "cargo build";
-    testCmds.rust = testCmds.rust ?? "cargo test";
-  }
-
-  if (Object.keys(buildCmds).length === 0) {
-    buildCmds.verify = runner === "bun" ? "bun run typecheck" : "echo \"Add build/typecheck command\"";
-  }
-
-  if (Object.keys(testCmds).length === 0) {
-    testCmds.tests = runner === "bun" ? "bun test" : "echo \"Add test command\"";
-  }
-
-  const specsPathCandidates = [
-    join(repoRoot, "docs/specs/engineering.md"),
-    join(repoRoot, "docs/specs"),
-    join(repoRoot, "specs"),
-    promptSpecPath,
-  ];
-
-  const chosenSpecs = specsPathCandidates.find((candidate) => existsSync(candidate)) ?? promptSpecPath;
-
-  const projectName = basename(repoRoot);
-  const maxConcurrency = Math.min(Math.max(Number(process.env.WORKFLOW_MAX_CONCURRENCY ?? "6") || 6, 1), 32);
-
-  return {
-    projectName,
-    projectId: slugify(projectName),
-    focuses: [
-      { id: "core", name: "Core Platform" },
-      { id: "api", name: "API and Data" },
-      { id: "workflow", name: "Workflow and Automation" },
-    ],
-    specsPath: chosenSpecs,
-    referenceFiles: [
-      promptSpecPath,
-      existsSync(join(repoRoot, "README.md")) ? "README.md" : "",
-      existsSync(join(repoRoot, "docs")) ? "docs" : "",
-    ].filter(Boolean),
-    buildCmds,
-    testCmds,
-    preLandChecks: Object.values(buildCmds),
-    postLandChecks: Object.values(testCmds),
-    codeStyle: "Follow existing project conventions and keep changes minimal and test-driven.",
-    reviewChecklist: [
-      "Spec compliance",
-      "Tests cover behavior changes",
-      "No regression risk in existing flows",
-      "Error handling and observability",
-    ],
-    maxConcurrency,
-  };
-}
-
 function findSmithersCliPath(repoRoot: string): string | null {
   const candidates = [
     join(repoRoot, "node_modules/smithers-orchestrator/src/cli/index.ts"),
@@ -309,7 +210,12 @@ function renderWorkflowFile(params: {
   return `import React from "react";
 import { createSmithers, ClaudeCodeAgent, CodexAgent, Sequence, Parallel } from "smithers-orchestrator";
 import { SuperRalph } from "${importPrefix}";
-import { InterpretConfig, Monitor } from "${importPrefix}/components";
+import {
+  InterpretConfig,
+  Monitor,
+  normalizeAgentSafetyPolicy,
+  type AgentSafetyPolicy,
+} from "${importPrefix}/components";
 import { ralphOutputSchemas } from "${importPrefix}";
 
 const REPO_ROOT = ${JSON.stringify(repoRoot)};
@@ -327,84 +233,177 @@ const { smithers, outputs, Workflow } = createSmithers(
   { dbPath: DB_PATH }
 );
 
-function createClaude(systemPrompt: string) {
+function resolveAgentSafetyPolicy(input: unknown): AgentSafetyPolicy {
+  const envRiskyModeEnabled = process.env.SUPER_RALPH_RISKY_MODE === "1";
+  const envApprovalRequiredPhases = (process.env.SUPER_RALPH_APPROVAL_REQUIRED_PHASES ?? "")
+    .split(",")
+    .map((phase) => phase.trim())
+    .filter((phase) => phase.length > 0);
+
+  if (!envRiskyModeEnabled) {
+    return normalizeAgentSafetyPolicy(input);
+  }
+
+  const normalizedInput = normalizeAgentSafetyPolicy(input);
+  return normalizeAgentSafetyPolicy({
+    riskyModeEnabled: true,
+    approvalRequiredPhases:
+      envApprovalRequiredPhases.length > 0
+        ? envApprovalRequiredPhases
+        : normalizedInput.approvalRequiredPhases,
+  });
+}
+
+function createClaude(systemPrompt: string, policy: AgentSafetyPolicy) {
+  const safeDefaults = {
+    yolo: false,
+    dangerouslySkipPermissions: false,
+  };
+
   return new ClaudeCodeAgent({
+    ...safeDefaults,
     model: "claude-sonnet-4-6",
     systemPrompt,
     cwd: REPO_ROOT,
-    dangerouslySkipPermissions: true,
+    yolo: policy.riskyModeEnabled,
+    dangerouslySkipPermissions: policy.riskyModeEnabled,
     timeoutMs: 60 * 60 * 1000,
   });
 }
 
-function createCodex(systemPrompt: string) {
+function createCodex(systemPrompt: string, policy: AgentSafetyPolicy) {
+  const safeDefaults = {
+    yolo: false,
+  };
+
   return new CodexAgent({
+    ...safeDefaults,
     model: "gpt-5.3-codex",
     systemPrompt,
     cwd: REPO_ROOT,
-    yolo: true,
+    yolo: policy.riskyModeEnabled,
     timeoutMs: 60 * 60 * 1000,
   });
 }
 
-function choose(primary: "claude" | "codex", systemPrompt: string) {
-  if (primary === "claude" && HAS_CLAUDE) return createClaude(systemPrompt);
-  if (primary === "codex" && HAS_CODEX) return createCodex(systemPrompt);
-  if (HAS_CLAUDE) return createClaude(systemPrompt);
-  return createCodex(systemPrompt);
+function choose(primary: "claude" | "codex", systemPrompt: string, policy: AgentSafetyPolicy) {
+  if (primary === "claude" && HAS_CLAUDE) return createClaude(systemPrompt, policy);
+  if (primary === "codex" && HAS_CODEX) return createCodex(systemPrompt, policy);
+  if (HAS_CLAUDE) return createClaude(systemPrompt, policy);
+  return createCodex(systemPrompt, policy);
 }
 
-const planningAgent = choose("claude", "Plan and research next tickets.");
-const implementationAgent = choose("claude", "Implement with test-driven development and jj workflows.");
-const testingAgent = choose("claude", "Run tests and validate behavior changes.");
-const reviewingAgent = choose("codex", "Review for regressions, spec drift, and correctness.");
-const reportingAgent = choose("claude", "Write concise, accurate ticket status reports.");
-
-export default smithers((ctx) => (
-  <Workflow name="super-ralph-full">
-    <Sequence>
-      {/* Step 1: Interpret Config (clarification session already collected by CLI) */}
-      <InterpretConfig
-        prompt={PROMPT_TEXT}
-        clarificationSession={CLARIFICATION_SESSION}
-        repoRoot={REPO_ROOT}
-        fallbackConfig={FALLBACK_CONFIG}
-        packageScripts={PACKAGE_SCRIPTS}
-        detectedAgents={{
-          claude: HAS_CLAUDE,
-          codex: HAS_CODEX,
-          gh: false,
-        }}
-        agent={planningAgent}
-      />
-
-      {/* Step 2: Run SuperRalph + Monitor in Parallel */}
-      <Parallel>
-        <SuperRalph
-          ctx={ctx}
-          outputs={outputs}
-          {...((ctx.outputMaybe("interpret-config", outputs.interpret_config) as any) || FALLBACK_CONFIG)}
-          agents={{
-            planning: planningAgent,
-            implementation: implementationAgent,
-            testing: testingAgent,
-            reviewing: reviewingAgent,
-            reporting: reportingAgent,
-          }}
-        />
+function mergeCommandMap(
+  fallback: Record<string, string>,
+  candidate: unknown,
+): Record<string, string> {
+  const merged = { ...fallback };
+  if (!candidate || typeof candidate !== "object") return merged;
 
-        <Monitor
-          dbPath={DB_PATH}
-          runId={ctx.runId}
-          config={(ctx.outputMaybe("interpret-config", outputs.interpret_config) as any) || FALLBACK_CONFIG}
-          clarificationSession={CLARIFICATION_SESSION}
+  for (const [key, value] of Object.entries(candidate as Record<string, unknown>)) {
+    if (typeof value === "string" && value.trim().length > 0) {
+      merged[key] = value;
+    }
+  }
+
+  return merged;
+}
+
+function resolveRuntimeConfig(ctx: any) {
+  const interpreted = (ctx.outputMaybe("interpret-config", outputs.interpret_config) as any) ?? {};
+  const buildCmds = mergeCommandMap(FALLBACK_CONFIG.buildCmds, interpreted.buildCmds);
+  const testCmds = mergeCommandMap(FALLBACK_CONFIG.testCmds, interpreted.testCmds);
+
+  const preLandChecks = Array.isArray(interpreted.preLandChecks) && interpreted.preLandChecks.length > 0
+    ? interpreted.preLandChecks
+    : Object.values(buildCmds);
+
+  const postLandChecks = Array.isArray(interpreted.postLandChecks) && interpreted.postLandChecks.length > 0
+    ? interpreted.postLandChecks
+    : Object.values(testCmds);
+
+  return {
+    ...FALLBACK_CONFIG,
+    ...interpreted,
+    buildCmds,
+    testCmds,
+    preLandChecks,
+    postLandChecks,
+  };
+}
+
+export default smithers((ctx) => {
+  const runtimeConfig = resolveRuntimeConfig(ctx);
+  const agentSafetyPolicy = resolveAgentSafetyPolicy(runtimeConfig.agentSafetyPolicy);
+  const planningAgent = choose("claude", "Plan and research next tickets.", agentSafetyPolicy);
+  const implementationAgent = choose(
+    "claude",
+    "Implement with test-driven development and jj workflows.",
+    agentSafetyPolicy,
+  );
+  const testingAgent = choose(
+    "claude",
+    "Run tests and validate behavior changes.",
+    agentSafetyPolicy,
+  );
+  const reviewingAgent = choose(
+    "codex",
+    "Review for regressions, spec drift, and correctness.",
+    agentSafetyPolicy,
+  );
+  const reportingAgent = choose(
+    "claude",
+    "Write concise, accurate ticket status reports.",
+    agentSafetyPolicy,
+  );
+
+  return (
+    <Workflow name="super-ralph-full">
+      <Sequence>
+        {/* Step 1: Interpret Config (clarification session already collected by CLI) */}
+        <InterpretConfig
           prompt={PROMPT_TEXT}
+          clarificationSession={CLARIFICATION_SESSION}
           repoRoot={REPO_ROOT}
+          fallbackConfig={FALLBACK_CONFIG}
+          packageScripts={PACKAGE_SCRIPTS}
+          detectedAgents={{
+            claude: HAS_CLAUDE,
+            codex: HAS_CODEX,
+            gh: false,
+          }}
+          agent={planningAgent}
         />
-      </Parallel>
-    </Sequence>
-  </Workflow>
-));
+
+        {/* Step 2: Run SuperRalph + Monitor in Parallel */}
+        <Parallel>
+          <SuperRalph
+            ctx={ctx}
+            outputs={outputs}
+            {...runtimeConfig}
+            agents={{
+              planning: planningAgent,
+              implementation: implementationAgent,
+              testing: testingAgent,
+              reviewing: reviewingAgent,
+              reporting: reportingAgent,
+            }}
+            agentSafetyPolicy={agentSafetyPolicy}
+          />
+
+          <Monitor
+            dbPath={DB_PATH}
+            runId={ctx.runId}
+            config={runtimeConfig}
+            clarificationSession={CLARIFICATION_SESSION}
+            prompt={PROMPT_TEXT}
+            repoRoot={REPO_ROOT}
+          />
+        </Parallel>
+      </Sequence>
+    </Workflow>
+  );
+});
 `;
 }
 
diff --git a/src/components/InterpretConfig.tsx b/src/components/InterpretConfig.tsx
index 77be1f5..c25a2a8 100644
--- a/src/components/InterpretConfig.tsx
+++ b/src/components/InterpretConfig.tsx
@@ -14,14 +14,17 @@ export const interpretConfigOutputSchema = z.object({
   focuses: z.array(focusSchema).min(1).max(12),
   specsPath: z.string().min(1),
   referenceFiles: z.array(z.string()),
-  buildCmds: z.record(z.string(), z.string()),
-  testCmds: z.record(z.string(), z.string()),
-  preLandChecks: z.array(z.string()),
-  postLandChecks: z.array(z.string()),
+  // Avoid emitting JSON Schema `propertyNames` from z.record(...)
+  // because Codex structured output rejects it.
+  buildCmds: z.object({}).catchall(z.string()),
+  testCmds: z.object({}).catchall(z.string()),
+  preLandChecks: z.array(z.string()).min(1),
+  postLandChecks: z.array(z.string()).min(1),
   codeStyle: z.string().min(1),
   reviewChecklist: z.array(z.string()).min(1),
   maxConcurrency: z.number().int().min(1).max(64),
-  reasoning: z.string().optional(),
+  // Codex structured output expects every declared property in `required`.
+  reasoning: z.string(),
 });
 
 export type InterpretConfigOutput = z.infer<typeof interpretConfigOutputSchema>;
@@ -112,6 +115,9 @@ export function InterpretConfig({
     "- Keep focuses concise (2-6).",
     "- Prefer paths relative to repo root.",
     "- Include the user prompt file as a reference when relevant.",
+    "- Gate fields are mandatory: buildCmds, testCmds, preLandChecks, postLandChecks.",
+    "- preLandChecks and postLandChecks must be non-empty arrays.",
+    "- If package scripts include typecheck/test, include both commands in the gate config.",
     "- Never return null; omit fields instead.",
     clarificationSession
       ? "- CRITICAL: Interpret and apply the user's clarification answers to tailor the config."
diff --git a/src/components/SuperRalph.tsx b/src/components/SuperRalph.tsx
index 96d1c69..b90a16f 100644
--- a/src/components/SuperRalph.tsx
+++ b/src/components/SuperRalph.tsx
@@ -16,6 +16,12 @@ import CodeReviewPrompt from "../prompts/CodeReview.mdx";
 import ReviewFixPrompt from "../prompts/ReviewFix.mdx";
 import ReportPrompt from "../prompts/Report.mdx";
 import CategoryReviewPrompt from "../prompts/CategoryReview.mdx";
+import { resolveTicketGateSelection } from "./ticket-gates";
+import {
+  normalizeAgentSafetyPolicy,
+  requiresApprovalForPhase,
+  type AgentSafetyPolicy,
+} from "./agent-safety-policy";
 import {
   buildSpeculativeMergeQueuePrompt,
   createSpeculativeMergeQueueAgent,
@@ -55,6 +61,7 @@ export type SuperRalphProps = {
 
   // Configuration
   progressFile?: string;
+  progressBookmark?: string;
   findingsFile?: string;
   commitConfig?: {
     prefix?: string;
@@ -79,6 +86,7 @@ export type SuperRalphProps = {
   /** Merge queue id used to isolate coordinator state */
   mergeQueueId?: string;
   skipPhases?: Set<string>;
+  agentSafetyPolicy?: AgentSafetyPolicy;
 
   // Advanced: Override any step with custom component
   updateProgress?: ReactElement;
@@ -149,6 +157,7 @@ export function SuperRalph({
   taskRetries = 3,
   agents,
   progressFile = "PROGRESS.md",
+  progressBookmark = "progress/update-progress",
   findingsFile = "docs/test-suite-findings.md",
   commitConfig = {},
   testSuites = [],
@@ -160,6 +169,7 @@ export function SuperRalph({
   maxSpeculativeDepth = 3,
   mergeQueueId = "land-queue",
   skipPhases = new Set(),
+  agentSafetyPolicy: rawAgentSafetyPolicy,
 
   // Advanced overrides
   updateProgress: customUpdateProgress,
@@ -193,6 +203,7 @@ export function SuperRalph({
   const mergeQueueAgent = normalizeAgent(
     agents.mergeQueue ?? createSpeculativeMergeQueueAgent(),
   );
+  const agentSafetyPolicy = normalizeAgentSafetyPolicy(rawAgentSafetyPolicy);
 
   const ciCommands = postLandChecks.length > 0 ? postLandChecks : Object.values(testCmds);
 
@@ -229,11 +240,16 @@ export function SuperRalph({
     <Ralph until={false} maxIterations={Infinity} onMaxReached="return-last">
       <Parallel maxConcurrency={maxConcurrency}>
         {!skipPhases.has("PROGRESS") && (customUpdateProgress || (
-          <Worktree id="wt-update-progress" path="/tmp/workflow-wt-update-progress">
+          <Worktree
+            id="wt-update-progress"
+            path="/tmp/workflow-wt-update-progress"
+            branch={progressBookmark}
+          >
             <Task id="update-progress" output={outputs.progress} agent={reportingAgent} retries={taskRetries}>
               <UpdateProgressPrompt
                 projectName={projectName}
                 progressFile={progressFile}
+                progressBookmark={progressBookmark}
                 commitMessage={`${prefix} docs: update progress`}
                 completedTickets={completedTicketIds}
               />
@@ -308,6 +324,13 @@ export function SuperRalph({
           const ticketImplementationAgent = roundRobinAgent(implementationAgent, ticketIndex);
           const ticketTestingAgent = roundRobinAgent(testingAgent, ticketIndex);
           const ticketReportingAgent = roundRobinAgent(reportingAgent, ticketIndex);
+          const ticketGateSelection = resolveTicketGateSelection({
+            ticketId: ticket.id,
+            ticketCategory: ticket.category,
+            buildCmds,
+            testCmds,
+            preLandChecks,
+          });
 
           const mergeQueueRequest: MergeQueueRequest = {
             runId: ctx.runId,
@@ -390,7 +413,16 @@ export function SuperRalph({
                       return (
                         <>
                           {customImplement || (
-                            <Task id={`${ticket.id}:implement`} output={outputs.implement} agent={ticketImplementationAgent} retries={taskRetries}>
+                            <Task
+                              id={`${ticket.id}:implement`}
+                              output={outputs.implement}
+                              agent={ticketImplementationAgent}
+                              retries={taskRetries}
+                              needsApproval={requiresApprovalForPhase(
+                                "implement",
+                                agentSafetyPolicy,
+                              )}
+                            >
                               <ImplementPrompt
                                 ticketId={ticket.id}
                                 ticketTitle={ticket.title}
@@ -405,7 +437,7 @@ export function SuperRalph({
                                 testWritingGuidance={["Write unit tests AND integration tests"]}
                                 implementationGuidance={["Follow architecture patterns from specs"]}
                                 formatterCommands={Object.entries(buildCmds).map(([lang, cmd]) => `Format ${lang}`)}
-                                verifyCommands={Object.values(buildCmds)}
+                                verifyCommands={ticketGateSelection.verifyCommands}
                                 architectureRules={[`Read ${specsPath} for patterns`]}
                                 commitPrefix={prefix}
                                 mainBranch={mainBranch}
@@ -420,11 +452,11 @@ export function SuperRalph({
                                 ticketId={ticket.id}
                                 ticketTitle={ticket.title}
                                 ticketCategory={ticket.category}
-                                testSuites={testSuites.length > 0 ? testSuites : Object.entries(testCmds).map(([name, command]) => ({
-                                  name: `${name} tests`,
-                                  command,
-                                  description: `Run ${name} tests`,
-                                }))}
+                                testSuites={
+                                  testSuites.length > 0
+                                    ? testSuites
+                                    : ticketGateSelection.testSuites
+                                }
                                 fixCommitPrefix={`üêõ fix`}
                                 mainBranch={mainBranch}
                               />
@@ -480,7 +512,16 @@ export function SuperRalph({
                           </Parallel>
 
                           {customReviewFix || (!noReviewIssues && (
-                            <Task id={`${ticket.id}:review-fix`} output={outputs.review_fix} agent={ticketImplementationAgent} retries={taskRetries}>
+                            <Task
+                              id={`${ticket.id}:review-fix`}
+                              output={outputs.review_fix}
+                              agent={ticketImplementationAgent}
+                              retries={taskRetries}
+                              needsApproval={requiresApprovalForPhase(
+                                "review-fix",
+                                agentSafetyPolicy,
+                              )}
+                            >
                               <ReviewFixPrompt
                                 ticketId={ticket.id}
                                 ticketTitle={ticket.title}
@@ -491,7 +532,7 @@ export function SuperRalph({
                                 codeSeverity={worstCodeSeverity}
                                 codeFeedback={mergedCodeFeedback}
                                 codeIssues={mergedCodeIssues.length > 0 ? mergedCodeIssues : null}
-                                validationCommands={Object.values(testCmds)}
+                                validationCommands={ticketGateSelection.validationCommands}
                                 commitPrefix={`üêõ fix`}
                                 mainBranch={mainBranch}
                                 emojiPrefixes={emojiPrefixes}
@@ -527,7 +568,16 @@ export function SuperRalph({
               {/* Phase 2: Landing (stateful speculative merge queue coordinator) */}
               <MergeQueue id={mergeQueueId} maxConcurrency={Math.max(1, maxSpeculativeDepth)}>
                 {customLand || (
-                  <Task id={`${ticket.id}:land`} output={outputs.land} agent={mergeQueueAgent} retries={taskRetries}>
+                  <Task
+                    id={`${ticket.id}:land`}
+                    output={outputs.land}
+                    agent={mergeQueueAgent}
+                    retries={taskRetries}
+                    needsApproval={requiresApprovalForPhase(
+                      "land",
+                      agentSafetyPolicy,
+                    )}
+                  >
                     {buildSpeculativeMergeQueuePrompt(mergeQueueRequest)}
                   </Task>
                 )}
diff --git a/src/components/agent-safety-policy.ts b/src/components/agent-safety-policy.ts
new file mode 100644
index 0000000..063bbc4
--- /dev/null
+++ b/src/components/agent-safety-policy.ts
@@ -0,0 +1,71 @@
+const RISKY_PHASES = ["implement", "review-fix", "land"] as const;
+
+type RiskyPhase = (typeof RISKY_PHASES)[number];
+
+export type AgentSafetyPolicy = {
+  riskyModeEnabled: boolean;
+  approvalRequiredPhases: string[];
+};
+
+function toRiskyPhase(phase: unknown): RiskyPhase | null {
+  if (typeof phase !== "string") return null;
+
+  const normalized = phase.trim().toLowerCase();
+  if (normalized.length === 0) return null;
+
+  return RISKY_PHASES.includes(normalized as RiskyPhase)
+    ? (normalized as RiskyPhase)
+    : null;
+}
+
+export function normalizeAgentSafetyPolicy(input: unknown): AgentSafetyPolicy {
+  if (!input || typeof input !== "object") {
+    return {
+      riskyModeEnabled: false,
+      approvalRequiredPhases: [],
+    };
+  }
+
+  const raw = input as {
+    riskyModeEnabled?: unknown;
+    approvalRequiredPhases?: unknown;
+  };
+
+  if (raw.riskyModeEnabled !== true) {
+    return {
+      riskyModeEnabled: false,
+      approvalRequiredPhases: [],
+    };
+  }
+
+  const requested = Array.isArray(raw.approvalRequiredPhases)
+    ? raw.approvalRequiredPhases
+    : [];
+  const approvalRequiredPhases: RiskyPhase[] = [];
+
+  for (const phase of requested) {
+    const normalized = toRiskyPhase(phase);
+    if (!normalized || approvalRequiredPhases.includes(normalized)) continue;
+    approvalRequiredPhases.push(normalized);
+  }
+
+  return {
+    riskyModeEnabled: true,
+    approvalRequiredPhases:
+      approvalRequiredPhases.length > 0
+        ? approvalRequiredPhases
+        : [...RISKY_PHASES],
+  };
+}
+
+export function requiresApprovalForPhase(
+  phase: string,
+  policy: AgentSafetyPolicy,
+): boolean {
+  if (policy.riskyModeEnabled !== true) return false;
+
+  const normalizedPhase = toRiskyPhase(phase);
+  if (!normalizedPhase) return false;
+
+  return policy.approvalRequiredPhases.includes(normalizedPhase);
+}
diff --git a/src/components/index.ts b/src/components/index.ts
index f39fc15..1de282d 100644
--- a/src/components/index.ts
+++ b/src/components/index.ts
@@ -1,5 +1,10 @@
 export { SuperRalph } from "./SuperRalph";
 export type { SuperRalphProps } from "./SuperRalph";
+export {
+  normalizeAgentSafetyPolicy,
+  requiresApprovalForPhase,
+} from "./agent-safety-policy";
+export type { AgentSafetyPolicy } from "./agent-safety-policy";
 
 export { ClarifyingQuestions, clarifyingQuestionsOutputSchema, generateQuestionsOutputSchema } from "./ClarifyingQuestions";
 export type { ClarifyingQuestionsOutput, ClarifyingQuestionsProps } from "./ClarifyingQuestions";
diff --git a/src/components/ticket-gates.ts b/src/components/ticket-gates.ts
new file mode 100644
index 0000000..ceac40d
--- /dev/null
+++ b/src/components/ticket-gates.ts
@@ -0,0 +1,150 @@
+export type ResolveTicketGateSelectionParams = {
+  ticketId?: string;
+  ticketCategory: string;
+  buildCmds: Record<string, string>;
+  testCmds: Record<string, string>;
+  preLandChecks: string[];
+};
+
+export type TicketGateSelection = {
+  verifyCommands: string[];
+  validationCommands: string[];
+  testSuites: Array<{
+    name: string;
+    command: string;
+    description: string;
+  }>;
+};
+
+const NON_RUNNABLE_GATE_PATTERNS = [/No .* configured yet/i, /\|\|\s*echo\b/i, /^echo\b/i];
+
+function normalizeCategory(ticketCategory: string, ticketId?: string): string {
+  const normalized = ticketCategory.trim().toLowerCase();
+  const normalizedId = (ticketId ?? "").trim().toUpperCase();
+  if (!normalized) return "default";
+
+  if (normalized.includes("workflow")) return "workflow";
+  if (normalized.includes("api")) return "api";
+  if (normalized.includes("db") || normalized.includes("data")) return "db";
+  if (normalized.includes("core")) return "core";
+  if (normalized.includes("test")) {
+    if (normalizedId.startsWith("API-")) return "api";
+    if (normalizedId.startsWith("DB-") || normalizedId.startsWith("DATA-")) return "db";
+  }
+  return normalized;
+}
+
+function toRunnableCommand(command: string | undefined): string | null {
+  if (typeof command !== "string") return null;
+  const normalized = command.trim();
+  if (!normalized) return null;
+
+  for (const pattern of NON_RUNNABLE_GATE_PATTERNS) {
+    if (pattern.test(normalized)) {
+      return null;
+    }
+  }
+
+  return normalized;
+}
+
+function uniqueCommands(commands: string[]): string[] {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+
+  for (const command of commands) {
+    const normalized = command.trim();
+    if (!normalized || seen.has(normalized)) continue;
+    if (!toRunnableCommand(normalized)) {
+      throw new Error(`Resolved non-runnable gate command: ${normalized}`);
+    }
+    seen.add(normalized);
+    unique.push(normalized);
+  }
+
+  if (unique.length === 0) {
+    throw new Error("Resolved non-runnable gate command: no runnable commands found");
+  }
+
+  return unique;
+}
+
+function defaultTestCommand(testCmds: Record<string, string>): string {
+  const preferred = toRunnableCommand(testCmds.test);
+  if (preferred) return preferred;
+
+  throw new Error("No runnable test command configured for ticket gates");
+}
+
+export const resolveCategoryTestCommand = (
+  ticketCategory: string,
+  testCmds: Record<string, string>,
+  ticketId?: string,
+): string => {
+  const normalizedCategory = normalizeCategory(ticketCategory, ticketId);
+
+  const categoryCommand = normalizedCategory === "core"
+    ? testCmds.core
+    : normalizedCategory === "api"
+      ? testCmds.api
+      : normalizedCategory === "workflow"
+        ? testCmds.workflow
+        : normalizedCategory === "db"
+          ? testCmds.db
+          : undefined;
+
+  const runnableCategoryCommand = toRunnableCommand(categoryCommand);
+  if (runnableCategoryCommand) return runnableCategoryCommand;
+
+  return defaultTestCommand(testCmds);
+};
+
+export const resolveVerifyCommands = (params: ResolveTicketGateSelectionParams): string[] => {
+  const { ticketId, ticketCategory, buildCmds, testCmds, preLandChecks } = params;
+  const categoryTestCommand = resolveCategoryTestCommand(
+    ticketCategory,
+    testCmds,
+    ticketId,
+  );
+
+  const candidateChecks = preLandChecks.length > 0
+    ? [...preLandChecks]
+    : [buildCmds.typecheck ?? Object.values(buildCmds)[0] ?? ""];
+
+  if (buildCmds.typecheck && !candidateChecks.includes(buildCmds.typecheck)) {
+    candidateChecks.unshift(buildCmds.typecheck);
+  }
+
+  candidateChecks.push(categoryTestCommand);
+  const verifyCommands = uniqueCommands(candidateChecks);
+  if (verifyCommands.length === 0) {
+    throw new Error("Resolved non-runnable gate command: no verify commands");
+  }
+
+  return verifyCommands;
+};
+
+export const resolveTicketGateSelection = (
+  params: ResolveTicketGateSelectionParams,
+): TicketGateSelection => {
+  const normalizedCategory = normalizeCategory(params.ticketCategory, params.ticketId);
+  const testCommand = resolveCategoryTestCommand(
+    params.ticketCategory,
+    params.testCmds,
+    params.ticketId,
+  );
+  const verifyCommands = resolveVerifyCommands(params);
+  const validationCommands = uniqueCommands([...verifyCommands]);
+
+  return {
+    verifyCommands,
+    validationCommands,
+    testSuites: [
+      {
+        name: `${normalizedCategory} tests`,
+        command: testCommand,
+        description: `Run ${normalizedCategory} tests`,
+      },
+    ],
+  };
+};
diff --git a/src/mergeQueue/coordinator.ts b/src/mergeQueue/coordinator.ts
index 4a8450a..bab6f27 100644
--- a/src/mergeQueue/coordinator.ts
+++ b/src/mergeQueue/coordinator.ts
@@ -101,8 +101,13 @@ export type MergeQueueRequest = {
 
 const REQUEST_MARKER = "SUPER_RALPH_SPECULATIVE_MERGE_QUEUE_REQUEST";
 
-function bookmarkRev(ticketId: string): string {
-  return `bookmark("ticket/${ticketId}")`;
+function escapeRevsetString(value: string): string {
+  return value.replace(/\\/g, "\\\\").replace(/"/g, '\\"');
+}
+
+function ticketBookmarkRevset(ticketId: string): string {
+  const escapedTicketId = escapeRevsetString(ticketId);
+  return `bookmarks("ticket/${escapedTicketId}")`;
 }
 
 function truncate(text: string, maxChars = 12000): string {
@@ -172,7 +177,7 @@ async function runCiInSpeculativeWorkspace(
   try {
     const added = await workspaceAdd(workspaceName, workspacePath, {
       cwd: repoRoot,
-      atRev: bookmarkRev(ticket.ticketId),
+      atRev: ticketBookmarkRevset(ticket.ticketId),
     });
     if (!added.success) {
       return {
@@ -207,19 +212,19 @@ async function collectDefaultEvictionContext(
   const attemptedLog = await runJjCommand(repoRoot, [
     "log",
     "-r",
-    `main..${bookmarkRev(ticketId)}`,
+    `main..${ticketBookmarkRevset(ticketId)}`,
     "--reversed",
   ]);
   const attemptedDiff = await runJjCommand(repoRoot, [
     "diff",
     "-r",
-    `roots(main..${bookmarkRev(ticketId)})`,
+    `roots(main..${ticketBookmarkRevset(ticketId)})`,
     "--summary",
   ]);
   const landedOnMain = await runJjCommand(repoRoot, [
     "log",
     "-r",
-    `${bookmarkRev(ticketId)}..main`,
+    `${ticketBookmarkRevset(ticketId)}..main`,
     "--reversed",
   ]);
 
@@ -261,7 +266,7 @@ export function createDefaultMergeQueueOps(): MergeQueueOps {
         await runJjCommand(repoRoot, [
           "rebase",
           "-b",
-          bookmarkRev(ticketId),
+          ticketBookmarkRevset(ticketId),
           "-d",
           destinationRev,
         ]),
@@ -278,7 +283,7 @@ export function createDefaultMergeQueueOps(): MergeQueueOps {
           "set",
           "main",
           "-r",
-          bookmarkRev(ticketId),
+          ticketBookmarkRevset(ticketId),
         ]),
       );
     },
@@ -554,7 +559,7 @@ export class SpeculativeMergeQueueCoordinator {
     for (const entry of entries) {
       const commit = await this.ops.readCommitId(
         this.repoRoot,
-        bookmarkRev(entry.ticket.ticketId),
+        ticketBookmarkRevset(entry.ticket.ticketId),
       );
       const retestNote =
         entry.invalidatedCount > 0
diff --git a/src/prompts/Land.mdx b/src/prompts/Land.mdx
index e665f25..0401efa 100644
--- a/src/prompts/Land.mdx
+++ b/src/prompts/Land.mdx
@@ -19,8 +19,8 @@ jj git fetch
 Before rebasing, check what other tickets landed on main since this branch diverged. This helps you catch **semantic conflicts** (code that doesn't cause git conflicts but breaks at runtime ‚Äî e.g. renamed functions, changed signatures, moved files, altered behavior your code depends on).
 
 ```
-jj log -r 'main..bookmark("ticket/{props.ticketId}")' --reversed
-jj diff -r 'roots(main..bookmark("ticket/{props.ticketId}"))' --summary
+jj log -r 'main..bookmarks("ticket/{props.ticketId}")' --reversed
+jj diff -r 'roots(main..bookmarks("ticket/{props.ticketId}"))' --summary
 ```
 
 Review the log and diff carefully. If other tickets modified files or APIs that your branch also touches, check for:
@@ -33,7 +33,7 @@ Review the log and diff carefully. If other tickets modified files or APIs that
 ### Step 3: Rebase branch onto latest main
 
 ```
-jj rebase -b 'bookmark("ticket/{props.ticketId}") ' -d main
+jj rebase -b 'bookmarks("ticket/{props.ticketId}") ' -d main
 ```
 
 If there are explicit conflicts, resolve them and describe the resolution.
@@ -56,7 +56,7 @@ If CI fails, output `{ "merged": false, "mergeCommit": null, "ciPassed": false,
 
 If CI passes:
 ```
-jj bookmark set main -r 'bookmark("ticket/{props.ticketId}")'
+jj bookmark set main -r 'bookmarks("ticket/{props.ticketId}")'
 ```
 
 ### Step 6: Push main
diff --git a/src/prompts/UpdateProgress.mdx b/src/prompts/UpdateProgress.mdx
index 7626ebb..9f99523 100644
--- a/src/prompts/UpdateProgress.mdx
+++ b/src/prompts/UpdateProgress.mdx
@@ -22,9 +22,13 @@ Do NOT run build commands, test commands, or compilation. Those are expensive an
 
 ## Commit
 
-After updating, commit your changes in this worktree:
+After updating, create a bookmark-visible checkpoint in this worktree:
 ```
 jj describe -m "{props.commitMessage || 'üìù docs: update progress report'}"
+jj bookmark set {props.progressBookmark || 'progress/update-progress'} -r @
+jj new
+jj git push --bookmark {props.progressBookmark || 'progress/update-progress'}
+jj log -r 'ancestors(bookmarks("{props.progressBookmark || 'progress/update-progress'}")) & @-' --no-graph -T commit_id
 ```
 
-Do NOT run `jj bookmark set main` or `jj git push` ‚Äî landing is handled separately.
+Do NOT update `main` in this phase. Only update and push the progress bookmark so checkpoints stay auditable.
