diff --git a/package.json b/package.json
index 2368a78..093cbea 100644
--- a/package.json
+++ b/package.json
@@ -13,7 +13,11 @@
     ".": "./src/index.ts",
     "./selectors": "./src/selectors.ts",
     "./components": "./src/components/index.ts",
-    "./cli/clarifications": "./src/cli/clarifications.ts"
+    "./schemas": "./src/schemas.ts",
+    "./gate-config": "./src/cli/gate-config.ts",
+    "./ticket-gates": "./src/components/ticket-gates.ts",
+    "./cli/clarifications": "./src/cli/clarifications.ts",
+    "./cli/fallback-config": "./src/cli/fallback-config.ts"
   },
   "files": [
     "src/",
diff --git a/src/cli/index.ts b/src/cli/index.ts
old mode 100644
new mode 100755
index 633e857..c60186d
--- a/src/cli/index.ts
+++ b/src/cli/index.ts
@@ -18,9 +18,10 @@
 
 import { existsSync } from "node:fs";
 import { mkdir, readFile, writeFile } from "node:fs/promises";
-import { basename, dirname, join, resolve } from "node:path";
+import { dirname, join, resolve } from "node:path";
 import { fileURLToPath } from "node:url";
 import { randomUUID } from "node:crypto";
+import { buildFallbackConfig } from "./fallback-config";
 
 type ParsedArgs = {
   positional: string[];
@@ -113,27 +114,6 @@ async function loadPackageScripts(repoRoot: string): Promise<Record<string, stri
   }
 }
 
-function detectScriptRunner(repoRoot: string): "bun" | "pnpm" | "yarn" | "npm" {
-  if (existsSync(join(repoRoot, "bun.lock")) || existsSync(join(repoRoot, "bun.lockb"))) return "bun";
-  if (existsSync(join(repoRoot, "pnpm-lock.yaml"))) return "pnpm";
-  if (existsSync(join(repoRoot, "yarn.lock"))) return "yarn";
-  return "npm";
-}
-
-function scriptCommand(runner: "bun" | "pnpm" | "yarn" | "npm", scriptName: string): string {
-  if (runner === "bun") return `bun run ${scriptName}`;
-  if (runner === "pnpm") return `pnpm run ${scriptName}`;
-  if (runner === "yarn") return `yarn ${scriptName}`;
-  return `npm run ${scriptName}`;
-}
-
-function slugify(value: string): string {
-  return value
-    .toLowerCase()
-    .replace(/[^a-z0-9]+/g, "-")
-    .replace(/^-+|-+$/g, "") || "project";
-}
-
 async function commandExists(command: string, cwd: string): Promise<boolean> {
   try {
     const proc = Bun.spawn(["which", command], { cwd, stdout: "pipe", stderr: "pipe" });
@@ -154,85 +134,6 @@ async function detectAgents(repoRoot: string): Promise<{ claude: boolean; codex:
   return { claude, codex, gh };
 }
 
-function buildFallbackConfig(repoRoot: string, promptSpecPath: string, packageScripts: Record<string, string>) {
-  const runner = detectScriptRunner(repoRoot);
-
-  const buildCmds: Record<string, string> = {};
-  const testCmds: Record<string, string> = {};
-
-  if (packageScripts.typecheck) {
-    buildCmds.typecheck = scriptCommand(runner, "typecheck");
-  }
-  if (packageScripts.build) {
-    buildCmds.build = scriptCommand(runner, "build");
-  }
-  if (packageScripts.lint) {
-    buildCmds.lint = scriptCommand(runner, "lint");
-  }
-
-  if (packageScripts.test) {
-    testCmds.test = scriptCommand(runner, "test");
-  }
-
-  if (existsSync(join(repoRoot, "go.mod"))) {
-    buildCmds.go = buildCmds.go ?? "go build ./...";
-    testCmds.go = testCmds.go ?? "go test ./...";
-  }
-
-  if (existsSync(join(repoRoot, "Cargo.toml"))) {
-    buildCmds.rust = buildCmds.rust ?? "cargo build";
-    testCmds.rust = testCmds.rust ?? "cargo test";
-  }
-
-  if (Object.keys(buildCmds).length === 0) {
-    buildCmds.verify = runner === "bun" ? "bun run typecheck" : "echo \"Add build/typecheck command\"";
-  }
-
-  if (Object.keys(testCmds).length === 0) {
-    testCmds.tests = runner === "bun" ? "bun test" : "echo \"Add test command\"";
-  }
-
-  const specsPathCandidates = [
-    join(repoRoot, "docs/specs/engineering.md"),
-    join(repoRoot, "docs/specs"),
-    join(repoRoot, "specs"),
-    promptSpecPath,
-  ];
-
-  const chosenSpecs = specsPathCandidates.find((candidate) => existsSync(candidate)) ?? promptSpecPath;
-
-  const projectName = basename(repoRoot);
-  const maxConcurrency = Math.min(Math.max(Number(process.env.WORKFLOW_MAX_CONCURRENCY ?? "6") || 6, 1), 32);
-
-  return {
-    projectName,
-    projectId: slugify(projectName),
-    focuses: [
-      { id: "core", name: "Core Platform" },
-      { id: "api", name: "API and Data" },
-      { id: "workflow", name: "Workflow and Automation" },
-    ],
-    specsPath: chosenSpecs,
-    referenceFiles: [
-      promptSpecPath,
-      existsSync(join(repoRoot, "README.md")) ? "README.md" : "",
-      existsSync(join(repoRoot, "docs")) ? "docs" : "",
-    ].filter(Boolean),
-    buildCmds,
-    testCmds,
-    preLandChecks: Object.values(buildCmds),
-    postLandChecks: Object.values(testCmds),
-    codeStyle: "Follow existing project conventions and keep changes minimal and test-driven.",
-    reviewChecklist: [
-      "Spec compliance",
-      "Tests cover behavior changes",
-      "No regression risk in existing flows",
-      "Error handling and observability",
-    ],
-    maxConcurrency,
-  };
-}
-
 function findSmithersCliPath(repoRoot: string): string | null {
   const candidates = [
     join(repoRoot, "node_modules/smithers-orchestrator/src/cli/index.ts"),
@@ -360,51 +261,94 @@ const testingAgent = choose("claude", "Run tests and validate behavior changes."
 const reviewingAgent = choose("codex", "Review for regressions, spec drift, and correctness.");
 const reportingAgent = choose("claude", "Write concise, accurate ticket status reports.");
 
-export default smithers((ctx) => (
-  <Workflow name="super-ralph-full">
-    <Sequence>
-      {/* Step 1: Interpret Config (clarification session already collected by CLI) */}
-      <InterpretConfig
-        prompt={PROMPT_TEXT}
-        clarificationSession={CLARIFICATION_SESSION}
-        repoRoot={REPO_ROOT}
-        fallbackConfig={FALLBACK_CONFIG}
-        packageScripts={PACKAGE_SCRIPTS}
-        detectedAgents={{
-          claude: HAS_CLAUDE,
-          codex: HAS_CODEX,
-          gh: false,
-        }}
-        agent={planningAgent}
-      />
-
-      {/* Step 2: Run SuperRalph + Monitor in Parallel */}
-      <Parallel>
-        <SuperRalph
-          ctx={ctx}
-          outputs={outputs}
-          {...((ctx.outputMaybe("interpret-config", outputs.interpret_config) as any) || FALLBACK_CONFIG)}
-          agents={{
-            planning: planningAgent,
-            implementation: implementationAgent,
-            testing: testingAgent,
-            reviewing: reviewingAgent,
-            reporting: reportingAgent,
-          }}
-        />
+function mergeCommandMap(
+  fallback: Record<string, string>,
+  candidate: unknown,
+): Record<string, string> {
+  const merged = { ...fallback };
+  if (!candidate || typeof candidate !== "object") return merged;
 
-        <Monitor
-          dbPath={DB_PATH}
-          runId={ctx.runId}
-          config={(ctx.outputMaybe("interpret-config", outputs.interpret_config) as any) || FALLBACK_CONFIG}
-          clarificationSession={CLARIFICATION_SESSION}
+  for (const [key, value] of Object.entries(candidate as Record<string, unknown>)) {
+    if (typeof value === "string" && value.trim().length > 0) {
+      merged[key] = value;
+    }
+  }
+
+  return merged;
+}
+
+function resolveRuntimeConfig(ctx: any) {
+  const interpreted = (ctx.outputMaybe("interpret-config", outputs.interpret_config) as any) ?? {};
+  const buildCmds = mergeCommandMap(FALLBACK_CONFIG.buildCmds, interpreted.buildCmds);
+  const testCmds = mergeCommandMap(FALLBACK_CONFIG.testCmds, interpreted.testCmds);
+
+  const preLandChecks = Array.isArray(interpreted.preLandChecks) && interpreted.preLandChecks.length > 0
+    ? interpreted.preLandChecks
+    : Object.values(buildCmds);
+
+  const postLandChecks = Array.isArray(interpreted.postLandChecks) && interpreted.postLandChecks.length > 0
+    ? interpreted.postLandChecks
+    : Object.values(testCmds);
+
+  return {
+    ...FALLBACK_CONFIG,
+    ...interpreted,
+    buildCmds,
+    testCmds,
+    preLandChecks,
+    postLandChecks,
+  };
+}
+
+export default smithers((ctx) => {
+  const runtimeConfig = resolveRuntimeConfig(ctx);
+
+  return (
+    <Workflow name="super-ralph-full">
+      <Sequence>
+        {/* Step 1: Interpret Config (clarification session already collected by CLI) */}
+        <InterpretConfig
           prompt={PROMPT_TEXT}
+          clarificationSession={CLARIFICATION_SESSION}
           repoRoot={REPO_ROOT}
+          fallbackConfig={FALLBACK_CONFIG}
+          packageScripts={PACKAGE_SCRIPTS}
+          detectedAgents={{
+            claude: HAS_CLAUDE,
+            codex: HAS_CODEX,
+            gh: false,
+          }}
+          agent={planningAgent}
         />
-      </Parallel>
-    </Sequence>
-  </Workflow>
-));
+
+        {/* Step 2: Run SuperRalph + Monitor in Parallel */}
+        <Parallel>
+          <SuperRalph
+            ctx={ctx}
+            outputs={outputs}
+            {...runtimeConfig}
+            agents={{
+              planning: planningAgent,
+              implementation: implementationAgent,
+              testing: testingAgent,
+              reviewing: reviewingAgent,
+              reporting: reportingAgent,
+            }}
+          />
+
+          <Monitor
+            dbPath={DB_PATH}
+            runId={ctx.runId}
+            config={runtimeConfig}
+            clarificationSession={CLARIFICATION_SESSION}
+            prompt={PROMPT_TEXT}
+            repoRoot={REPO_ROOT}
+          />
+        </Parallel>
+      </Sequence>
+    </Workflow>
+  );
+});
 `;
 }
 
diff --git a/src/components/InterpretConfig.tsx b/src/components/InterpretConfig.tsx
index 77be1f5..c25a2a8 100644
--- a/src/components/InterpretConfig.tsx
+++ b/src/components/InterpretConfig.tsx
@@ -14,14 +14,17 @@ export const interpretConfigOutputSchema = z.object({
   focuses: z.array(focusSchema).min(1).max(12),
   specsPath: z.string().min(1),
   referenceFiles: z.array(z.string()),
-  buildCmds: z.record(z.string(), z.string()),
-  testCmds: z.record(z.string(), z.string()),
-  preLandChecks: z.array(z.string()),
-  postLandChecks: z.array(z.string()),
+  // Avoid emitting JSON Schema `propertyNames` from z.record(...)
+  // because Codex structured output rejects it.
+  buildCmds: z.object({}).catchall(z.string()),
+  testCmds: z.object({}).catchall(z.string()),
+  preLandChecks: z.array(z.string()).min(1),
+  postLandChecks: z.array(z.string()).min(1),
   codeStyle: z.string().min(1),
   reviewChecklist: z.array(z.string()).min(1),
   maxConcurrency: z.number().int().min(1).max(64),
-  reasoning: z.string().optional(),
+  // Codex structured output expects every declared property in `required`.
+  reasoning: z.string(),
 });
 
 export type InterpretConfigOutput = z.infer<typeof interpretConfigOutputSchema>;
@@ -112,6 +115,9 @@ export function InterpretConfig({
     "- Keep focuses concise (2-6).",
     "- Prefer paths relative to repo root.",
     "- Include the user prompt file as a reference when relevant.",
+    "- Gate fields are mandatory: buildCmds, testCmds, preLandChecks, postLandChecks.",
+    "- preLandChecks and postLandChecks must be non-empty arrays.",
+    "- If package scripts include typecheck/test, include both commands in the gate config.",
     "- Never return null; omit fields instead.",
     clarificationSession
       ? "- CRITICAL: Interpret and apply the user's clarification answers to tailor the config."
diff --git a/src/components/SuperRalph.tsx b/src/components/SuperRalph.tsx
index 96d1c69..2db4704 100644
--- a/src/components/SuperRalph.tsx
+++ b/src/components/SuperRalph.tsx
@@ -16,6 +16,7 @@ import CodeReviewPrompt from "../prompts/CodeReview.mdx";
 import ReviewFixPrompt from "../prompts/ReviewFix.mdx";
 import ReportPrompt from "../prompts/Report.mdx";
 import CategoryReviewPrompt from "../prompts/CategoryReview.mdx";
+import { resolveTicketGateSelection } from "./ticket-gates";
 import {
   buildSpeculativeMergeQueuePrompt,
   createSpeculativeMergeQueueAgent,
@@ -308,6 +309,12 @@ export function SuperRalph({
           const ticketImplementationAgent = roundRobinAgent(implementationAgent, ticketIndex);
           const ticketTestingAgent = roundRobinAgent(testingAgent, ticketIndex);
           const ticketReportingAgent = roundRobinAgent(reportingAgent, ticketIndex);
+          const ticketGateSelection = resolveTicketGateSelection({
+            ticketCategory: ticket.category,
+            buildCmds,
+            testCmds,
+            preLandChecks,
+          });
 
           const mergeQueueRequest: MergeQueueRequest = {
             runId: ctx.runId,
@@ -405,7 +412,7 @@ export function SuperRalph({
                                 testWritingGuidance={["Write unit tests AND integration tests"]}
                                 implementationGuidance={["Follow architecture patterns from specs"]}
                                 formatterCommands={Object.entries(buildCmds).map(([lang, cmd]) => `Format ${lang}`)}
-                                verifyCommands={Object.values(buildCmds)}
+                                verifyCommands={ticketGateSelection.verifyCommands}
                                 architectureRules={[`Read ${specsPath} for patterns`]}
                                 commitPrefix={prefix}
                                 mainBranch={mainBranch}
@@ -420,11 +427,11 @@ export function SuperRalph({
                                 ticketId={ticket.id}
                                 ticketTitle={ticket.title}
                                 ticketCategory={ticket.category}
-                                testSuites={testSuites.length > 0 ? testSuites : Object.entries(testCmds).map(([name, command]) => ({
-                                  name: `${name} tests`,
-                                  command,
-                                  description: `Run ${name} tests`,
-                                }))}
+                                testSuites={
+                                  testSuites.length > 0
+                                    ? testSuites
+                                    : ticketGateSelection.testSuites
+                                }
                                 fixCommitPrefix={`üêõ fix`}
                                 mainBranch={mainBranch}
                               />
@@ -491,7 +498,7 @@ export function SuperRalph({
                                 codeSeverity={worstCodeSeverity}
                                 codeFeedback={mergedCodeFeedback}
                                 codeIssues={mergedCodeIssues.length > 0 ? mergedCodeIssues : null}
-                                validationCommands={Object.values(testCmds)}
+                                validationCommands={ticketGateSelection.validationCommands}
                                 commitPrefix={`üêõ fix`}
                                 mainBranch={mainBranch}
                                 emojiPrefixes={emojiPrefixes}
diff --git a/src/schemas.ts b/src/schemas.ts
index f616890..72bd642 100644
--- a/src/schemas.ts
+++ b/src/schemas.ts
@@ -14,9 +14,9 @@ const discoverTicketSchema = z.object({
   description: z.string(),
   category: z.string(),
   priority: z.enum(["critical", "high", "medium", "low"]),
-  acceptanceCriteria: z.array(z.string()).nullable().optional(),
-  relevantFiles: z.array(z.string()).nullable().optional(),
-  referenceFiles: z.array(z.string()).nullable().optional(),
+  acceptanceCriteria: z.array(z.string()).nullable(),
+  relevantFiles: z.array(z.string()).nullable(),
+  referenceFiles: z.array(z.string()).nullable(),
 });
 
 export const ralphOutputSchemas = {
@@ -165,11 +165,11 @@ export const ralphOutputSchemas = {
     mergeCommit: z.string().nullable(),
     ciPassed: z.boolean(),
     summary: z.string(),
-    evicted: z.boolean().default(false),
-    evictionReason: z.string().nullable().optional(),
-    evictionDetails: z.string().nullable().optional(),
-    attemptedLog: z.string().nullable().optional(),
-    attemptedDiffSummary: z.string().nullable().optional(),
-    landedOnMainSinceBranch: z.string().nullable().optional(),
+    evicted: z.boolean(),
+    evictionReason: z.string().nullable(),
+    evictionDetails: z.string().nullable(),
+    attemptedLog: z.string().nullable(),
+    attemptedDiffSummary: z.string().nullable(),
+    landedOnMainSinceBranch: z.string().nullable(),
   }),
 };
diff --git a/src/cli/gate-config.ts b/src/cli/gate-config.ts
new file mode 100644
index 0000000..23febe5
--- /dev/null
+++ b/src/cli/gate-config.ts
@@ -0,0 +1,92 @@
+export type ScriptRunner = "bun" | "pnpm" | "yarn" | "npm";
+
+export type GateCommandConfig = {
+  buildCmds: Record<string, string>;
+  testCmds: Record<string, string>;
+  preLandChecks: string[];
+  postLandChecks: string[];
+};
+
+const REQUIRED_GATE_SCRIPTS = ["test", "typecheck"] as const;
+
+function hasScript(packageScripts: Record<string, string>, scriptName: string): boolean {
+  const command = packageScripts[scriptName];
+  return typeof command === "string" && command.trim().length > 0;
+}
+
+function scriptCommand(runner: ScriptRunner, scriptName: string): string {
+  if (runner === "bun") return `bun run ${scriptName}`;
+  if (runner === "pnpm") return `pnpm run ${scriptName}`;
+  if (runner === "yarn") return `yarn ${scriptName}`;
+  return `npm run ${scriptName}`;
+}
+
+function firstExistingScript(packageScripts: Record<string, string>, candidates: string[]): string | null {
+  for (const scriptName of candidates) {
+    if (hasScript(packageScripts, scriptName)) {
+      return scriptName;
+    }
+  }
+
+  return null;
+}
+
+export const assertRequiredGateScripts = (packageScripts: Record<string, string>): void => {
+  const missingScripts = REQUIRED_GATE_SCRIPTS.filter((scriptName) => !hasScript(packageScripts, scriptName));
+
+  if (missingScripts.length > 0) {
+    throw new Error(`Missing required package scripts: ${missingScripts.join(", ")}`);
+  }
+};
+
+export const resolveFocusTestCommands = (
+  runner: ScriptRunner,
+  packageScripts: Record<string, string>,
+): Record<string, string> => {
+  const testCmds: Record<string, string> = {
+    test: scriptCommand(runner, "test"),
+  };
+
+  const focusScriptCandidates: Record<string, string[]> = {
+    core: ["test:core", "test:unit:core", "test:integration:core"],
+    api: ["test:integration:api", "test:api"],
+    workflow: ["test:integration:workflow", "test:workflow"],
+    db: ["test:integration:db", "test:db"],
+  };
+
+  for (const [focus, candidates] of Object.entries(focusScriptCandidates)) {
+    const selectedScript = firstExistingScript(packageScripts, candidates);
+    if (selectedScript) {
+      testCmds[focus] = scriptCommand(runner, selectedScript);
+    }
+  }
+
+  return testCmds;
+};
+
+export const buildGateCommandConfig = (
+  runner: ScriptRunner,
+  packageScripts: Record<string, string>,
+): GateCommandConfig => {
+  assertRequiredGateScripts(packageScripts);
+
+  const buildCmds: Record<string, string> = {
+    typecheck: scriptCommand(runner, "typecheck"),
+  };
+
+  if (hasScript(packageScripts, "build")) {
+    buildCmds.build = scriptCommand(runner, "build");
+  }
+  if (hasScript(packageScripts, "lint")) {
+    buildCmds.lint = scriptCommand(runner, "lint");
+  }
+
+  const testCmds = resolveFocusTestCommands(runner, packageScripts);
+
+  return {
+    buildCmds,
+    testCmds,
+    preLandChecks: Object.values(buildCmds),
+    postLandChecks: Object.values(testCmds),
+  };
+};
diff --git a/src/cli/fallback-config.ts b/src/cli/fallback-config.ts
new file mode 100644
index 0000000..965dccd
--- /dev/null
+++ b/src/cli/fallback-config.ts
@@ -0,0 +1,85 @@
+import { existsSync } from "node:fs";
+import { basename, join } from "node:path";
+
+import {
+  buildGateCommandConfig,
+  type ScriptRunner,
+} from "./gate-config";
+
+export function detectScriptRunner(repoRoot: string): ScriptRunner {
+  if (existsSync(join(repoRoot, "bun.lock")) || existsSync(join(repoRoot, "bun.lockb"))) return "bun";
+  if (existsSync(join(repoRoot, "pnpm-lock.yaml"))) return "pnpm";
+  if (existsSync(join(repoRoot, "yarn.lock"))) return "yarn";
+  return "npm";
+}
+
+function slugify(value: string): string {
+  return value
+    .toLowerCase()
+    .replace(/[^a-z0-9]+/g, "-")
+    .replace(/^-+|-+$/g, "") || "project";
+}
+
+export function buildFallbackConfig(
+  repoRoot: string,
+  promptSpecPath: string,
+  packageScripts: Record<string, string>,
+) {
+  const runner = detectScriptRunner(repoRoot);
+  const gateConfig = buildGateCommandConfig(runner, packageScripts);
+  const buildCmds: Record<string, string> = { ...gateConfig.buildCmds };
+  const testCmds: Record<string, string> = { ...gateConfig.testCmds };
+
+  if (existsSync(join(repoRoot, "go.mod"))) {
+    buildCmds.go = buildCmds.go ?? "go build ./...";
+    testCmds.go = testCmds.go ?? "go test ./...";
+  }
+
+  if (existsSync(join(repoRoot, "Cargo.toml"))) {
+    buildCmds.rust = buildCmds.rust ?? "cargo build";
+    testCmds.rust = testCmds.rust ?? "cargo test";
+  }
+
+  const specsPathCandidates = [
+    join(repoRoot, "docs/specs/engineering.md"),
+    join(repoRoot, "docs/specs"),
+    join(repoRoot, "specs"),
+    promptSpecPath,
+  ];
+
+  const chosenSpecs = specsPathCandidates.find((candidate) => existsSync(candidate)) ?? promptSpecPath;
+
+  const projectName = basename(repoRoot);
+  const maxConcurrency = Math.min(
+    Math.max(Number(process.env.WORKFLOW_MAX_CONCURRENCY ?? "6") || 6, 1),
+    32,
+  );
+
+  return {
+    projectName,
+    projectId: slugify(projectName),
+    focuses: [
+      { id: "core", name: "Core Platform" },
+      { id: "api", name: "API and Data" },
+      { id: "workflow", name: "Workflow and Automation" },
+    ],
+    specsPath: chosenSpecs,
+    referenceFiles: [
+      promptSpecPath,
+      existsSync(join(repoRoot, "README.md")) ? "README.md" : "",
+      existsSync(join(repoRoot, "docs")) ? "docs" : "",
+    ].filter(Boolean),
+    buildCmds,
+    testCmds,
+    preLandChecks: Object.values(buildCmds),
+    postLandChecks: Object.values(testCmds),
+    codeStyle: "Follow existing project conventions and keep changes minimal and test-driven.",
+    reviewChecklist: [
+      "Spec compliance",
+      "Tests cover behavior changes",
+      "No regression risk in existing flows",
+      "Error handling and observability",
+    ],
+    maxConcurrency,
+  };
+}
diff --git a/src/components/ticket-gates.ts b/src/components/ticket-gates.ts
new file mode 100644
index 0000000..eb92c44
--- /dev/null
+++ b/src/components/ticket-gates.ts
@@ -0,0 +1,98 @@
+export type ResolveTicketGateSelectionParams = {
+  ticketCategory: string;
+  buildCmds: Record<string, string>;
+  testCmds: Record<string, string>;
+  preLandChecks: string[];
+};
+
+export type TicketGateSelection = {
+  verifyCommands: string[];
+  validationCommands: string[];
+  testSuites: Array<{
+    name: string;
+    command: string;
+    description: string;
+  }>;
+};
+
+function normalizeCategory(ticketCategory: string): string {
+  const normalized = ticketCategory.trim().toLowerCase();
+  if (!normalized) return "default";
+
+  if (normalized.includes("workflow")) return "workflow";
+  if (normalized.includes("api")) return "api";
+  if (normalized.includes("db") || normalized.includes("data")) return "db";
+  if (normalized.includes("core")) return "core";
+  return normalized;
+}
+
+function uniqueCommands(commands: string[]): string[] {
+  const seen = new Set<string>();
+  const unique: string[] = [];
+
+  for (const command of commands) {
+    const normalized = command.trim();
+    if (!normalized || seen.has(normalized)) continue;
+    seen.add(normalized);
+    unique.push(normalized);
+  }
+
+  return unique;
+}
+
+function defaultTestCommand(testCmds: Record<string, string>): string {
+  if (testCmds.test) return testCmds.test;
+  const firstTestCommand = Object.values(testCmds).find((command) => command.trim().length > 0);
+  if (firstTestCommand) return firstTestCommand;
+  return "echo \"No test command configured yet\"";
+}
+
+export const resolveCategoryTestCommand = (
+  ticketCategory: string,
+  testCmds: Record<string, string>,
+): string => {
+  const normalizedCategory = normalizeCategory(ticketCategory);
+
+  if (normalizedCategory === "core" && testCmds.core) return testCmds.core;
+  if (normalizedCategory === "api" && testCmds.api) return testCmds.api;
+  if (normalizedCategory === "workflow" && testCmds.workflow) return testCmds.workflow;
+  if (normalizedCategory === "db" && testCmds.db) return testCmds.db;
+
+  return defaultTestCommand(testCmds);
+};
+
+export const resolveVerifyCommands = (params: ResolveTicketGateSelectionParams): string[] => {
+  const { ticketCategory, buildCmds, testCmds, preLandChecks } = params;
+  const categoryTestCommand = resolveCategoryTestCommand(ticketCategory, testCmds);
+
+  const candidateChecks = preLandChecks.length > 0
+    ? [...preLandChecks]
+    : [buildCmds.typecheck ?? Object.values(buildCmds)[0] ?? ""];
+
+  if (buildCmds.typecheck && !candidateChecks.includes(buildCmds.typecheck)) {
+    candidateChecks.unshift(buildCmds.typecheck);
+  }
+
+  candidateChecks.push(categoryTestCommand);
+  return uniqueCommands(candidateChecks);
+};
+
+export const resolveTicketGateSelection = (
+  params: ResolveTicketGateSelectionParams,
+): TicketGateSelection => {
+  const normalizedCategory = normalizeCategory(params.ticketCategory);
+  const testCommand = resolveCategoryTestCommand(params.ticketCategory, params.testCmds);
+  const verifyCommands = resolveVerifyCommands(params);
+
+  return {
+    verifyCommands,
+    validationCommands: [...verifyCommands],
+    testSuites: [
+      {
+        name: `${normalizedCategory} tests`,
+        command: testCommand,
+        description: `Run ${normalizedCategory} tests`,
+      },
+    ],
+  };
+};
